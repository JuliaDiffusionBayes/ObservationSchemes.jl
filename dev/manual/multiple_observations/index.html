<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Multiple observations · ObservationSchemes.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ObservationSchemes.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">ObservationSchemes.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../get_started/overview/">Get started</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">User manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../single_observation/">A single observation</a></li><li><a class="tocitem" href="../start_pt_prior/">Priors over starting points</a></li><li class="is-active"><a class="tocitem" href>Multiple observations</a><ul class="internal"><li><a class="tocitem" href="#Defining-a-single-recording-1"><span>Defining a single recording</span></a></li><li><a class="tocitem" href="#Defining-multiple-recordings-1"><span>Defining multiple recordings</span></a></li></ul></li><li><a class="tocitem" href="../observation_schemes/">Observation schemes</a></li><li><a class="tocitem" href="../utility_functions/">Utility fuctions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">How to...</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../how_to_guides/simple_os/">... ergonomically deal with simple observation schemes?</a></li><li><a class="tocitem" href="../../how_to_guides/custom_priors/">... define custom priors over starting points?</a></li><li><a class="tocitem" href="../../how_to_guides/custom_os/">... define custom observation schemes?</a></li><li><a class="tocitem" href="../../how_to_guides/dataframes/">... work with dataframes?</a></li><li><a class="tocitem" href="../../how_to_guides/csv_files/">... read data directly from a <code>.csv</code> file?</a></li><li><a class="tocitem" href="../../how_to_guides/save_to_files/">... save decorated data to a file?</a></li><li><a class="tocitem" href="../../how_to_guides/other_processes/">... deal with stochastic processes other than diffusions?</a></li><li><a class="tocitem" href="../../how_to_guides/update_params/">... leverage <code>AllObservations</code> to efficiently update parameters?</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/single_path/">Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model</a></li></ul></li><li><a class="tocitem" href="../../module_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User manual</a></li><li class="is-active"><a href>Multiple observations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Multiple observations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDiffusionBayes/ObservationSchemes.jl/blob/master/docs/src/manual/multiple_observations.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Multiple-observations-1"><a class="docs-heading-anchor" href="#Multiple-observations-1">Multiple observations</a><a class="docs-heading-anchor-permalink" href="#Multiple-observations-1" title="Permalink"></a></h1><hr/><p>In practice, we gather multiple observations of a single trajectory of a stochastic process. In this package, we refer to multiple discrete-time observations of a single trajectory as a single <strong>recording</strong>. We do not enforce any structure on a single recording and instead use a convention of using an appropriate <code>NamedTuple</code>. However, when combining <strong>multiple recordings</strong> into a single data object <code>AllObservations</code> it is expected that each <strong>recording</strong> follows the said convention.</p><p>Below we describe how to handle observations of</p><ul><li>a single recording</li><li>multiple recordings from the same law</li><li>multiple recordings from multiple laws</li></ul><h2 id="Defining-a-single-recording-1"><a class="docs-heading-anchor" href="#Defining-a-single-recording-1">Defining a single recording</a><a class="docs-heading-anchor-permalink" href="#Defining-a-single-recording-1" title="Permalink"></a></h2><hr/><p>To fully describe a single recording we need four elements:</p><ul><li>The law of the underlying stochastic process</li><li>A starting time</li><li>A prior over the starting point</li><li>Discrete-time observations of the process</li></ul><p>Consequently, this package adopts the convention of defining a single recording with a <code>NamedTuple</code>:</p><pre><code class="language-julia">recording = (
    P = ...,
    obs = ...,
    t0 = ...,
    x0_prior = ...,
)</code></pre><p>The law <code>P</code> needs to be defined by the user.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>To define diffusion laws you may use <a href="https://github.com/mmider/DiffusionDefinition.jl">DiffusionDefinition.jl</a>. To define conditioned diffusion laws you may use <a href="https://github.com/mmider/GuidedProposals.jl">GuidedProposals.jl</a>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>There must exist an implementation of a function <code>var_parameter_names(::typeof(P))</code> if one wants to use functions and structs presented below.</p></div></div><p><code>obs</code> is assumed to be a vector of observations, with each element being of the type inheriting from <code>Observation{D,T}</code>. <code>x0_prior</code> is assumed to inherit from <code>StartingPtPrior{T}</code>. We provide helper functions that create a <code>NamedTuple</code> in the format above:</p><article class="docstring"><header><a class="docstring-binding" id="ObservationSchemes.build_recording" href="#ObservationSchemes.build_recording"><code>ObservationSchemes.build_recording</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">build_recording(P, obs, t0, x0_prior)</code></pre><p>A utility function that creates an appropriate <code>NamedTuple</code> that represents a single recording.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/ObservationSchemes.jl/blob/4c45ab43609ad31c2116e7be012c02b55f5fca74/src/all_observations.jl#LL19-L24">source</a></section><section><div><pre><code class="language-julia">build_recording(
    ::Type{K}, tt, observs::Vector, P, t0, x0_prior; kwargs...
) where K</code></pre><p>A utility function for building a recording. Times of recordings are assumed to be stored in <code>tt</code> and their values in <code>observs</code>. <code>K</code> is the type of observation (for instance <code>LinearGsnObs</code>). <code>kwargs</code> are name arguments that are passed to every single initializer of <code>K</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/ObservationSchemes.jl/blob/4c45ab43609ad31c2116e7be012c02b55f5fca74/src/all_observations.jl#LL27-L35">source</a></section></article><h2 id="Defining-multiple-recordings-1"><a class="docs-heading-anchor" href="#Defining-multiple-recordings-1">Defining multiple recordings</a><a class="docs-heading-anchor-permalink" href="#Defining-multiple-recordings-1" title="Permalink"></a></h2><hr/><p>A struct <code>AllObservations</code> allows for a systematic definition of multiple recordings and, in addition, provides some handy functionality.</p><article class="docstring"><header><a class="docstring-binding" id="ObservationSchemes.AllObservations" href="#ObservationSchemes.AllObservations"><code>ObservationSchemes.AllObservations</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct AllObservations
    recordings::Vector{Any}
    param_depend::Dict{Symbol,Vector{Pair{Int64, Symbol}}}
    obs_depend::Dict{Symbol,Vector{Tuple{Int64,Int64,Int64}}}
    param_depend_rev::Vector{Vector{Tuple{Symbol,Symbol}}}
    obs_depend_rev::Vector{Vector{Vector{Tuple{Symbol,Int64}}}}
end</code></pre><p>A struct gathering multiple observations of diffusion processes. Additionaly, the interdependence structure between parameters shared between various diffusions laws used to generate the recorded data is kept.</p><ul><li><code>recordings</code>: collects all recordings</li><li><code>param_depend</code>: is a dictionary with<ul><li>keys: parameter labels</li><li>values: vectors that collect all indices of recordings whose laws depend         on a corresponding parameter (in fact collects <code>Pairs</code>:         <code>idx-of-a-recording =&gt; name-of-parameter</code>).</li></ul></li><li><code>obs_depend</code>: does the same as <code>param_depend</code> but for observations.               In this case values are vectors that collect <code>Tuple</code>s in a               format:               <code>(idx-of-a-recording, idx-of-an-observation,               idx-of-parameter-in-θ-vector)</code>.</li><li><code>param_depend_rev</code>: gives for each recording a list of <strong>variable</strong> parameters                     that its law depends on. These are given in a format                     <code>global-param-name =&gt; local-param-name</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We use the term variable to refer to those parameters that are returned after a call <code>var_parameter_names(typeof(P))</code>.</p></div></div><ul><li><code>obs_depend_rev</code>: does the same as <code>param_depend_rev</code> but for the                   observations. These are given in a format                   <code>global-param-name =&gt; local-param-idx</code>.</li></ul><hr/><pre><code class="language-none">AllObservations(;P=nothing, obs=nothing, t0=nothing, x0_prior=nothing)</code></pre><p>Default constructor creating either an empty <code>AllObservations</code> object, or initiating it immediately with a single recording where the target comes from the law <code>P</code>, the observations are stored in <code>obs</code> and the observed process was started at time <code>t0</code> from som position which we put a prior <code>x0_prior</code> on.</p><pre><code class="language-none">AllObservations(recording::NamedTuple)</code></pre><p>Constructor creating an <code>AllObservations</code> object and initiating it immediately with a single recording where the target comes from the law <code>recording.P</code>, the observations are stored in <code>recording.obs</code> and the starting point is at time <code>recording.t0</code> and has a prior <code>x0_prior</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/ObservationSchemes.jl/blob/4c45ab43609ad31c2116e7be012c02b55f5fca74/src/all_observations.jl#LL47-L97">source</a></section></article><h3 id="Recordings-that-share-a-single-law-1"><a class="docs-heading-anchor" href="#Recordings-that-share-a-single-law-1">Recordings that share a single law</a><a class="docs-heading-anchor-permalink" href="#Recordings-that-share-a-single-law-1" title="Permalink"></a></h3><p>We can define multiple recordings using functions</p><article class="docstring"><header><a class="docstring-binding" id="ObservationSchemes.add_recording!" href="#ObservationSchemes.add_recording!"><code>ObservationSchemes.add_recording!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_recording!(all_obs::AllObservations, recording::NamedTuple)</code></pre><p>Add a new recording <code>recording</code> to an observations container <code>all_obs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/ObservationSchemes.jl/blob/4c45ab43609ad31c2116e7be012c02b55f5fca74/src/all_observations.jl#LL166-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ObservationSchemes.add_recordings!" href="#ObservationSchemes.add_recordings!"><code>ObservationSchemes.add_recordings!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_recordings!(
    all_obs::AllObservations,
    recordings::AbstractArray{&lt;:NamedTuple}
)</code></pre><p>Add multiple new recordings <code>recordings</code> to an observations container <code>all_obs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/ObservationSchemes.jl/blob/4c45ab43609ad31c2116e7be012c02b55f5fca74/src/all_observations.jl#LL149-L156">source</a></section></article><p>for instance:</p><pre><code class="language-julia">const OBS = ObservationSchemes
struct LawA α; β; end
OBS.var_parameter_names(P::LawA) = (:α, :β)

recordings = [
    (
        P = LawA(10,20),
        obs = [
            LinearGsnObs(1.0, 1.0; Σ=1.0),
            LinearGsnObs(2.0, 2.0; full_obs=true),
            LinearGsnObs(3.0, 3.0; Σ=2.0),
        ],
        t0 = 0.0,
        x0_prior = KnownStartingPt(2.0),
    ), # recording n°1
    (
        P = LawA(10,20),
        obs = [
            LinearGsnObs(1.3, 1.0; full_obs=true),
            LinearGsnObs(2.3, 2.0; full_obs=true),
            LinearGsnObs(3.3, 3.0; full_obs=true),
        ],
        t0 = 0.3,
        x0_prior = KnownStartingPt(-2.0),
    ), # recording n°2
]

all_obs = AllObservations()
add_recordings!(all_obs, recordings)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In here we defined the vector <code>recordings</code> verbatim, however we provide an <code>ObsScheme</code> struct together with <code>@load_data</code> macro to do this in an automatic and concise way for many observations at once (see <a href="../observation_schemes/#obs_scheme-1">the following section</a> to learn more about this).</p></div></div><p>Observations can be accessed via <code>all_obs.recordings</code>. By default the laws from different recordings are assumed to be independent, but we can tell <code>AllObservations</code> object that they are the same by indicating that the laws share some subsets (possibly all) parameters. This can be done by passing an appropriate dictionary to a function:</p><article class="docstring"><header><a class="docstring-binding" id="ObservationSchemes.add_dependency!" href="#ObservationSchemes.add_dependency!"><code>ObservationSchemes.add_dependency!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_dependency!(all_obs::AllObservations, dep::Dict)</code></pre><p>Add a dependency structure <code>dep</code> between parameters shared across various laws and observations used to generate various recordings stored in an observations container <code>all_obs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/ObservationSchemes.jl/blob/4c45ab43609ad31c2116e7be012c02b55f5fca74/src/all_observations.jl#LL176-L182">source</a></section></article><pre><code class="language-julia">add_dependency!(
    all_obs,
    Dict(
        :α_shared =&gt; [(1, :α), (2, :α)],
        :β_shared =&gt; [(1, :β), (2, :β)],
    )
)</code></pre><p>The first (respectively second) entry in the dictionary tells <code>all_obs</code> that there is a parameter, which from now on will be labeled <code>:α_shared</code> (resp. <code>:β_shared</code>), that is present in the law of recording <code>1</code> and the law of recording <code>2</code> and in both of these cases if one calls <code>var_parameter_names(P)</code> then the referred to parameter should have a name <code>:α</code> (resp. <code>:β</code>).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the parameter appears in the observation instead of the law, then the previous tuple of the format <code>(rec_idx, :param-name)</code> must be substituted with: <code>(rec_idx, obs_idx, param_idx_in_obs_vec)</code>, for instance:</p><pre><code class="language-julia">add_dependency!(
    all_obs,
    Dict(
        :γ_shared =&gt; [(1, 2, 3), (40, 400, 4)],
    )
)</code></pre><p>indicates that there is a shared parameter <code>:γ_shared</code> that enters:</p><ul><li>the second observations in a first recording and that it is the third parameter of this observation</li><li>the 400th observation of the 40th recording and that it enters the 4th parameter of that observation</li></ul></div></div><p>Now, we can additionally call</p><article class="docstring"><header><a class="docstring-binding" id="ObservationSchemes.initialize" href="#ObservationSchemes.initialize"><code>ObservationSchemes.initialize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">initialize(all_obs::AllObservations)</code></pre><p>Split the recordings at the times of full observations to make full use of the Markov property (and make the code readily parallelisable). Introduce all <em>variable</em> parameters that were not mentioned in the current dependency dictionary. Create internal dictionaries <code>all_obs.param_depend_rev</code> and <code>all_obs.obs_depend_rev</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/ObservationSchemes.jl/blob/4c45ab43609ad31c2116e7be012c02b55f5fca74/src/all_observations.jl#LL234-L242">source</a></section></article><p>as in:</p><pre><code class="language-julia">initialised_all_obs, old_to_new_idx = initialize(all_obs)</code></pre><p>to perform three useful operations.</p><ol><li>First, all parameters that are not shared between various laws will be marked (here, there is no such parameter, so this step does not do anything, see the example below which illustrates this idea),</li><li>Second, the recordings are split at the times at which full observations are made, as full observations allows for employment of the Markov property and treatment of the problem in parallel. As a result, <code>initialised_all_obs</code> now has <code>5</code> recordings, all coming from the same law <code>LawA</code>.</li><li>Third, an additional dependence structure is introduced that allows for efficient retrieval of information about parameter dependence when iterating through laws and observations.</li></ol><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The <code>old_to_new_idx</code> might be helpful for keeping track of the original indices of recordings.</p></div></div><p>Some useful information is printed when we call</p><article class="docstring"><header><a class="docstring-binding" id="ObservationSchemes.print_parameters" href="#ObservationSchemes.print_parameters"><code>ObservationSchemes.print_parameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">print_parameters(all_obs::AllObservations)</code></pre><p>Print information about the variable parameters about which the <code>all_obs.param_depend</code> object stores some interdependency information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/ObservationSchemes.jl/blob/4c45ab43609ad31c2116e7be012c02b55f5fca74/src/all_observations_utilities.jl#LL1-L6">source</a></section></article><pre><code class="language-julia">julia&gt; print_parameters(initialised_all_obs)

There are 5 independent recordings.
There are also 2 variable parameters.
* * *
You may define the var-parameters using the following template:
# start of template
using OrderedCollections

θ_init = OrderedDict(
    :β_shared =&gt; ... , # param 1
    :α_shared =&gt; ... , # param 2
)
# end of template
and in an MCMC setting you may let your parameter update step
refer to a subset of indices you wish to update using the order
given above.
* * *</code></pre><p>We can also inspect the field <code>param_depend_rev</code>:</p><pre><code class="language-julia">julia&gt; initialised_all_obs.param_depend_rev
5-element Array{Array{Tuple{Symbol,Symbol},1},1}:
 [(:β_shared, :β), (:α_shared, :α)]
 [(:β_shared, :β), (:α_shared, :α)]
 [(:β_shared, :β), (:α_shared, :α)]
 [(:β_shared, :β), (:α_shared, :α)]
 [(:β_shared, :β), (:α_shared, :α)]</code></pre><p>which allows for iterating through recordings and seeing immediately which parameters they depend on, in particular:</p><ul><li>how these parameters are referred to by the <code>all_obs</code> struct</li><li>how these parameters are referred to by the individual laws</li></ul><h3 id="Recordings-under-multiple-laws-1"><a class="docs-heading-anchor" href="#Recordings-under-multiple-laws-1">Recordings under multiple laws</a><a class="docs-heading-anchor-permalink" href="#Recordings-under-multiple-laws-1" title="Permalink"></a></h3><p>It should be clear that the formalism above allows for definition of recordings coming from multiple diffusion laws. For instance, we can have</p><pre><code class="language-julia">struct LawB γ; β; end
OBS.var_parameter_names(P::LawB) = (:γ, :β)

extra_recording = (
    P = LawB(30,40),
    obs = [
        LinearGsnObs(1.5, 1.0; Σ=1.0),
        LinearGsnObs(2.5, 2.0; Σ=1.0),
    ],
    t0 = 0.5,
    x0_prior = KnownStartingPt(10.0),
) # recording n°3
push!(recordings, extra_recording)

all_obs = AllObservations()
add_recordings!(all_obs, recordings)</code></pre><p>The dictionary specifying interdependence between the laws of stochastic processes can now be defined as follows:</p><pre><code class="language-julia">add_dependency!(
    all_obs,
    Dict(
        :α_shared =&gt; [(1, :α), (2, :α)],
        :β_shared =&gt; [(1, :β), (2, :β), (3,:β)],
    )
)</code></pre><p>where, notice presence of additional <code>(3,:β)</code>. This time, calling</p><pre><code class="language-julia">initialised_all_obs, _ = initialize(all_obs)</code></pre><p>not only splits the recordings at the time of full observations (resulting in <code>6</code> independent recordings), but also introduces a new named parameter <code>REC3_γ</code> that only the last recording depends on. This comes from the fact that in the original <code>all_obs</code> the third recording came from law <code>LawB</code>, which depends on the parameter <code>γ</code> that was not shared with any other recording and hence did not appear in the inter-dependency dictionary. Every such &quot;lonely&quot; parameter is introduced by a function <code>initialize</code> and is given a name by pre-pending its original name with <code>REC($i)_</code>, with <code>($i)</code> denoting the original index of a recording that the parameter came from.</p><p>Now:</p><pre><code class="language-julia">julia&gt; print_parameters(initialised_all_obs)

There are 6 independent recordings.
There are also 3 variable parameters.
* * *
You may define the var-parameters using the following template:
# start of template
using OrderedCollections

θ_init = OrderedDict(
    :β_shared =&gt; ... , # param 1
    :α_shared =&gt; ... , # param 2
    :REC3_γ =&gt; ... , # param 3
)
# end of template
and in an MCMC setting you may let your parameter update step
refer to a subset of indices you wish to update using the order
given above.
* * *</code></pre><p>and</p><pre><code class="language-julia">julia&gt; initialised_all_obs.param_depend_rev
6-element Array{Array{Tuple{Symbol,Symbol},1},1}:
 [(:β_shared, :β), (:α_shared, :α)]
 [(:β_shared, :β), (:α_shared, :α)]
 [(:β_shared, :β), (:α_shared, :α)]
 [(:β_shared, :β), (:α_shared, :α)]
 [(:β_shared, :β), (:α_shared, :α)]
 [(:β_shared, :β), (:REC3_γ, :γ)]</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../start_pt_prior/">« Priors over starting points</a><a class="docs-footer-nextpage" href="../observation_schemes/">Observation schemes »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 12 June 2020 15:43">Friday 12 June 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
