<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>A single observation · ObservationSchemes.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ObservationSchemes.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../get_started/overview/">Get started</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">User manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>A single observation</a><ul class="internal"><li><a class="tocitem" href="#Linear-Gaussian-struct-1"><span>Linear Gaussian struct</span></a></li><li><a class="tocitem" href="#Parameterizing-LinearGsnObs-1"><span>Parameterizing <code>LinearGsnObs</code></span></a></li><li><a class="tocitem" href="#Non-linear,-non-Gaussian-observations-1"><span>Non-linear, non-Gaussian observations</span></a></li></ul></li><li><a class="tocitem" href="../start_pt_prior/">Priors over starting points</a></li><li><a class="tocitem" href="../multiple_observations/">Multiple observations</a></li><li><a class="tocitem" href="../observation_schemes/">Observation schemes</a></li><li><a class="tocitem" href="../utility_functions/">Utility fuctions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">How to...</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../how_to_guides/simple_os/">(TODO) Efficiently deal with simple observation schemes</a></li><li><a class="tocitem" href="../../how_to_guides/custom_priors/">(TODO) Define custom priors over starting points</a></li><li><a class="tocitem" href="../../how_to_guides/custom_os/">(TODO) Define custom observation schemes</a></li><li><a class="tocitem" href="../../how_to_guides/dataframes/">(TODO) Work with dataframes</a></li><li><a class="tocitem" href="../../how_to_guides/csv_files/">(TODO) Work with CSV files</a></li><li><a class="tocitem" href="../../how_to_guides/other_processes/">(TODO) Deal with other stochastic processes</a></li><li><a class="tocitem" href="../../how_to_guides/update_params/">(TODO) Update parameters for AllObservations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/single_path/">(TODO) Single path</a></li><li><a class="tocitem" href="../../tutorials/multi_paths/">(TODO) Multiple paths</a></li><li><a class="tocitem" href="../../tutorials/multi_paths_diff_observ/">(TODO) Multiple paths differently observed</a></li><li><a class="tocitem" href="../../tutorials/mixed_effect_models/">(TODO) Mixed effect models</a></li><li><a class="tocitem" href="../../tutorials/hmm/">(TODO) Observations of HMM driven by ARCH(1)</a></li></ul></li><li><a class="tocitem" href="../../module_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User manual</a></li><li class="is-active"><a href>A single observation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>A single observation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDiffusionBayes/ObservationSchemes.jl/blob/master/docs/src/manual/single_observation.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="manual_start-1"><a class="docs-heading-anchor" href="#manual_start-1">Observation schemes</a><a class="docs-heading-anchor-permalink" href="#manual_start-1" title="Permalink"></a></h1><hr/><p>All observation schemes inherit from</p><article class="docstring"><header><a class="docstring-binding" id="ObservationSchemes.Observation" href="#ObservationSchemes.Observation"><code>ObservationSchemes.Observation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Observation{D,T}</code></pre><p>Types inheriting from this struct provide all information about the observation of the stochastic process being made. <code>D</code> denotes the dimension of the observation whereas <code>T</code> its eltype.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/ObservationSchemes.jl/blob/9a166f32b7a40369fed96c8a052bf9ec68648a64/src/observations_common.jl#LL3-L9">source</a></section></article><p>and must have methods</p><article class="docstring"><header><a class="docstring-binding" id="Base.eltype" href="#Base.eltype"><code>Base.eltype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eltype(::K) where {K&lt;:Observation{D,T}}</code></pre><p>Eltype of the observation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/ObservationSchemes.jl/blob/9a166f32b7a40369fed96c8a052bf9ec68648a64/src/observations_common.jl#LL20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size" href="#Base.size"><code>Base.size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">size(::K) where {K&lt;:Observation{D}}</code></pre><p>Size of the observation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/ObservationSchemes.jl/blob/9a166f32b7a40369fed96c8a052bf9ec68648a64/src/observations_common.jl#LL27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length" href="#Base.length"><code>Base.length</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">length(::K) where {K&lt;:Observation{D}}</code></pre><p>Length of the observation (equal to a number of entries in a vector holding the data)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/ObservationSchemes.jl/blob/9a166f32b7a40369fed96c8a052bf9ec68648a64/src/observations_common.jl#LL34-L39">source</a></section></article><p>implemented for them. The idea is to decorate each recorded data-point with such structs, and in doing so, encode the way in which it was collected.</p><p>We implemented two concrete structs that may be used for defining a single observation:</p><ul><li><code>LinearGsnObs</code>: to encode observations of the linear transformations of the underlying process disturbed by Gaussian noise</li><li><code>GeneralObs</code>: to encode observations of non-linear transformations of the underlying process disturbed by noise.</li></ul><p>Both admit a possibility of parameterization.</p><h2 id="Linear-Gaussian-struct-1"><a class="docs-heading-anchor" href="#Linear-Gaussian-struct-1">Linear Gaussian struct</a><a class="docs-heading-anchor-permalink" href="#Linear-Gaussian-struct-1" title="Permalink"></a></h2><hr/><p>The most important observation scheme is <code>LinearGsnObs</code>.  It is suitable for representing observations that can be written in the following format:</p><div>\[\begin{equation}\label{eq:obs_scheme}
V_t := LX_t+\xi,\quad \xi\sim N(μ,Σ),
\end{equation}\]</div><p>where <span>$L\in\RR^{d\times d&#39;}$</span> and <span>$X_t$</span> is a state of the underlying stochastic process.</p><article class="docstring"><header><a class="docstring-binding" id="ObservationSchemes.LinearGsnObs" href="#ObservationSchemes.LinearGsnObs"><code>ObservationSchemes.LinearGsnObs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct LinearGsnObs{Tag,D,T,FPT,S,R,K} &lt;: Observation{D,T}
    L::S
    μ::T
    Σ::R
    obs::T
    t::Float64
    full_obs::Bool
    θ::Vector{K}
end</code></pre><p>Observation of the underlying process that is of the form: LX+ξ, where ξ∼N(μ,Σ) and L,Σ and μ are respectively matrices and a vector of appropriate dimensions. <code>FPT</code> stores information about first-passage times. <code>full_obs</code> is an indicator for whether it is a full observation of the process (as it grants the use of Markov Property). <code>θ</code> is a container that may contain parameters that enter <code>L</code>, <code>μ</code>, <code>Σ</code> and <code>Tag</code> is a disambiguation flag used at compile time or for multiple dispatch to differentiate between different observation types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/ObservationSchemes.jl/blob/9a166f32b7a40369fed96c8a052bf9ec68648a64/src/observations_linear_gaussian.jl#LL7-L26">source</a></section></article><p>Below, we list some special cases of the scheme above.</p><h3 id="Exact-observations-of-the-process-1"><a class="docs-heading-anchor" href="#Exact-observations-of-the-process-1">Exact observations of the process</a><a class="docs-heading-anchor-permalink" href="#Exact-observations-of-the-process-1" title="Permalink"></a></h3><p>A degenerate case of the setting above is an exact observation of <span>$X_t$</span>, i.e. when</p><div>\[L = I_d,\qquad μ = 0_{d\times 1},\qquad Σ = 0_{d\times d},\]</div><p>so that <span>$X_t=V_t$</span>. This can be defined as:</p><pre><code class="language-julia">t, v = 1.0, [1.0, 2.0, 3.0]
obs = LinearGsnObs(t, v; full_obs=true)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>For numerical reasons the covariance matrix of the noise <code>Σ</code> should not be a zero matrix, and instead, even in the exact observation setting should be inflated by some small <code>artificial noise</code>. By default <code>Σ</code> is set to <span>$\Sigma:=10^{-11}I_{d}$</span> for numerical reasons. This can be changed by specifying <code>Σ</code> explicitly, for instance to increase the level of <code>artificial noise</code>:</p><pre><code class="language-julia">using LinearAlgebra
obs = LinearGsnObs(t, v; Σ=(1e-5)I, full_obs=true)</code></pre></div></div><p>Specifying <code>full_obs=true</code> is important, as it lets the compiler differentiate between an actual, full observation with some artificial noise and a (possibly) partial observation with very low level (or also artificial level) of noise. <strong>As a result, Julia knows when the Markov property can be applied!</strong></p><p>We can view a summary of the observation by calling <code>summary</code>:</p><pre><code class="language-julia">julia&gt; summary(obs)
⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤
|Observation `v = Lx+ξ`, where `L` is a (3, 3)-matrix, `x` is a state of the stochastic process and `ξ`∼N(μ,Σ).
|...
|| v: [1.0, 2.0, 3.0] (observation),
||  → typeof(v): Array{Float64,1},
|| made at time 1.0.
|...
|L: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0],
|   → typeof(L): Diagonal{Float64,Array{Float64,1}}
|μ: [0.0, 0.0, 0.0],
|   → typeof(μ): Array{Float64,1}
|Σ: [1.0e-11 0.0 0.0; 0.0 1.0e-11 0.0; 0.0 0.0 1.0e-11],
|   → typeof(Σ): Diagonal{Float64,Array{Float64,1}}
|...
|This is an exact observation.
|...
|It does not depend on any additional parameters.
|...
|No first passage times recorded.
⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆</code></pre><p>Notice that various defaults and type-inferences have kicked in. It was recognized that the observation does not depend on any parameters, that first-passage time setting does not apply and that the observation was a mutable type and hence regular <code>Arrays</code> are used to define <code>L</code>, <code>μ</code> and <code>Σ</code>.</p><h3 id="standard_example_lingsnobs-1"><a class="docs-heading-anchor" href="#standard_example_lingsnobs-1">Linear transformations of the process disturbed by Gaussian noise</a><a class="docs-heading-anchor-permalink" href="#standard_example_lingsnobs-1" title="Permalink"></a></h3><p>This is a standard understanding of the expression in \eqref{eq:obs_scheme}. An example could be:</p><pre><code class="language-julia">using StaticArrays
v = @SVector [1.0, 2.0, 3.0]
t = 2.0
L = @SMatrix [1.0 0.0 2.0 0.0; 3.0 4.0 0.0 0.0; 0.0 1.0 0.0 1.0]
Σ = SDiagonal(1.0, 1.0, 1e-11)
obs = LinearGsnObs(t, v; L = L, Σ = Σ)</code></pre><p>for defining a three-dimensional observation <code>v</code> made at time <span>$2.0$</span> of a four-dimensional process <span>$X$</span>, where the first coordinate of the observation is <span>$X_t^{[1]}+2X_t^{[3]}+\xi^{[1]}$</span>, with <span>$\xi^{[1]}\sim N(0,1)$</span>, the second coordinate is <span>$3X_t^{[1]}+4X_t^{[2]}+\xi^{[2]}$</span>, with <span>$\xi^{[2]}\sim N(0,1)$</span>, and the third coordinate is <span>$X_t^{[2]}+X_t^{[4]}$</span>, with no real noise (only artificial one, needed for numerical reasons). We can display the summary of the observation with:</p><pre><code class="language-julia">julia&gt; summary(obs)
⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤
|Observation `v = Lx+ξ`, where `L` is a (3, 4)-matrix, `x` is a state of the stochastic process and `ξ`∼N(μ,Σ).
|...
|| v: [1.0, 2.0, 3.0] (observation),
||  → typeof(v): SArray{Tuple{3},Float64,1,3},
|| made at time 2.0.
|...
|L: [1.0 0.0 2.0 0.0; 3.0 4.0 0.0 0.0; 0.0 1.0 0.0 1.0],
|   → typeof(L): SArray{Tuple{3,4},Float64,2,12}
|μ: [0.0, 0.0, 0.0],
|   → typeof(μ): SArray{Tuple{3},Float64,1,3}
|Σ: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0e-11],
|   → typeof(Σ): Diagonal{Float64,SArray{Tuple{3},Float64,1,3}}
|...
|This is NOT an exact observation.
|...
|It does not depend on any additional parameters.
|...
|No first passage times recorded.
⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆</code></pre><p>Note that the internal containers are now set to be <code>SVector</code>s (even <code>μ</code>, which wasn&#39;t passed to a constructor but its type was inferred and its value set to zero). Additionally, Julia understands that this is not a full observation and hence Markov property cannot be applied.</p><h3 id="first_passage_time-1"><a class="docs-heading-anchor" href="#first_passage_time-1">First-passage time observations</a><a class="docs-heading-anchor-permalink" href="#first_passage_time-1" title="Permalink"></a></h3><p>Support for certain first-passage time settings is provided. By default <code>LinearGsnObs</code> sets the first-passage time info to <code>NoFirstPassageTimes</code>. However, this can be changed. For instance, to indicate in the example above that the last coordinate of <code>v</code> actually reaches level <span>$3.0$</span> for the very first time at time <span>$1.0$</span> we can specify the following:</p><pre><code class="language-julia">t, v = 1.0, [1.0, 2.0, 3.0]
fpt = FirstPassageTimeInfo(
    (3,),
    (3.0,),
    (true,),
    (false,),
    (),
)
obs = LinearGsnObs(t, v; L = L, Σ = Σ, fpt = fpt)</code></pre><p>The last two entries in <code>fpt</code> specify additional reset times. For instance, instead of <code>(false,)</code> and <code>()</code> we could set <code>(true,)</code>, <code>(-1.0)</code> to indicate that the process <span>$X_t^{[2]}+X_t^{[4]}$</span> can do whatever before it falls below level <span>$-1.0$</span> (in particular it can go above level <span>$3.0$</span>), and that once it falls below <span>$-1.0$</span>, then from then on the first time it reaches level <span>$3.0$</span> happens at time <span>$1.0$</span>. Note that</p><pre><code class="language-julia">julia&gt; summary(obs)
⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤
|Observation `v = Lx+ξ`, where `L` is a (3, 4)-matrix, `x` is a state of the stochastic process and `ξ`∼N(μ,Σ).
|...
|| v: [1.0, 2.0, 3.0] (observation),
||  → typeof(v): Array{Float64,1},
|| made at time 1.0.
|...
|L: [1.0 0.0 2.0 0.0; 3.0 4.0 0.0 0.0; 0.0 1.0 0.0 1.0],
|   → typeof(L): SArray{Tuple{3,4},Float64,2,12}
|μ: [0.0, 0.0, 0.0],
|   → typeof(μ): Array{Float64,1}
|Σ: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0e-11],
|   → typeof(Σ): Diagonal{Float64,SArray{Tuple{3},Float64,1,3}}
|...
|This is NOT an exact observation.
|...
|It does not depend on any additional parameters.
|...
|First passage times of the observation `v`:
|----------------------------------------------------------------------------
||  coordinate  |     level    |  up-crossing |  extra reset |  reset level |
|----------------------------------------------------------------------------
||       3      |      3.0     |  up-crossing |       ✘      |       ✘      |
⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆</code></pre><p>changes appropriately to display the new summary of the first-passage time information.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This package is agnostic with respect to the algorithms that are later used on the decorated observations. Consequently it doesn&#39;t make any checks for whether the observations make sense. For instance in the package <a href="https://github.com/JuliaDiffusionBayes/GuidedProposals.jl">GuidedProposals.jl</a> that deals with simulating conditioned diffusions, a support for first-passage time observations is currently extended only to diffusions  where the dynamics of the coordinate whose first-passage time is observed <strong>is devoid of any Wiener noise</strong>. The onus of checking whether this or other constraints are satisfied are on the user.</p></div></div><div class="admonition is-success"><header class="admonition-header">Why do we refer to `LinearGsnObs` as most important?</header><div class="admonition-body"><p>In practice, all other observation schemes are handled by approximating them with a suitable <code>LinearGsnObs</code> and then correcting the resulting approximation error with Metropolis-Hastings steps. Consequently, <code>LinearGsnObs</code> will be a building block of any other observation scheme.</p></div></div><h2 id="Parameterizing-LinearGsnObs-1"><a class="docs-heading-anchor" href="#Parameterizing-LinearGsnObs-1">Parameterizing <code>LinearGsnObs</code></a><a class="docs-heading-anchor-permalink" href="#Parameterizing-LinearGsnObs-1" title="Permalink"></a></h2><hr/><p>The observations can be parameterized by passing a vector of parameters <code>θ</code>. Additionally, a <code>Tag</code> needs to be attached that is used to differentiate at compile time between the non-parameterized observations and parameterized observations as well as among different parameterizations themselves.</p><p>For instance, to indicate in the <a href="#standard_example_lingsnobs-1">second example</a> that two entries in the <code>L</code> matrix are parameterized we can write:</p><pre><code class="language-julia">v = @SVector [1.0, 2.0, 3.0]
t = 2.0
L = @SMatrix [1.0 0.0 -99.9 0.0; 3.0 4.0 0.0 0.0; 0.0 -99.9 0.0 1.0]
Σ = SDiagonal(1.0, 1.0, 1e-11)
obs = LinearGsnObs(t, v; L = L, Σ = Σ, θ=[2.0, 1.0], Tag=1)</code></pre><p>We are not done yet, in this case matrix <code>L</code> that we passed above is incomplete as we intend to create an actual matrix <code>L</code> by combining the matrix and the parameters we&#39;ve passed. To this end, we must overwrite the behaviour of the function <code>L(⋅)</code>:</p><pre><code class="language-julia">const OBS = ObservationSchemes
function OBS.L(o::LinearGsnObs{1})
    _L = MMatrix{3,4,Float64}(o.L)
    _L[1,3] = o.θ[1]
    _L[3,2] = o.θ[2]
    SMatrix{3,4,Float64}(_L)
end</code></pre><p>Notice that we dispatch on the observation&#39;s tag <code>1</code>. Furthermore, when calling <code>summarize</code> matrix <code>L</code> is displayed correctly.</p><pre><code class="language-julia">julia&gt; summary(obs)
⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤
|Observation `v = Lx+ξ`, where `L` is a (3, 4)-matrix, `x` is a state of the stochastic process and `ξ`∼N(μ,Σ).
|...
|| ν: [1.0, 2.0, 3.0] (observation),
||  → typeof(ν): SArray{Tuple{3},Float64,1,3},
|| made at time 2.0.
|...
|L: [1.0 0.0 2.0 0.0; 3.0 4.0 0.0 0.0; 0.0 1.0 0.0 1.0],
|   → typeof(L): SArray{Tuple{3,4},Float64,2,12}
|μ: [0.0, 0.0, 0.0],
|   → typeof(μ): SArray{Tuple{3},Float64,1,3}
|Σ: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0e-11],
|   → typeof(Σ): Diagonal{Float64,SArray{Tuple{3},Float64,1,3}}
|...
|This is NOT an exact observation.
|...
|It depends on additional parameters, which are set to: (2.0, 1.0).
|...
|No first passage times recorded.
⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆</code></pre><p>However, now we can change parameters to new values and the matrix <code>L</code> will be updated:</p><pre><code class="language-julia">OBS.update_params!(obs, [7.0, 8.0])
julia&gt; summary(obs)
⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤
|Observation `v = Lx+ξ`, where `L` is a (3, 4)-matrix, `x` is a state of the stochastic process and `ξ`∼N(μ,Σ).
|...
|| ν: [1.0, 2.0, 3.0] (observation),
||  → typeof(ν): SArray{Tuple{3},Float64,1,3},
|| made at time 2.0.
|...
|L: [1.0 0.0 7.0 0.0; 3.0 4.0 0.0 0.0; 0.0 8.0 0.0 1.0],
|   → typeof(L): SArray{Tuple{3,4},Float64,2,12}
|μ: [0.0, 0.0, 0.0],
|   → typeof(μ): SArray{Tuple{3},Float64,1,3}
|Σ: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0e-11],
|   → typeof(Σ): Diagonal{Float64,SArray{Tuple{3},Float64,1,3}}
|...
|This is NOT an exact observation.
|...
|It depends on additional parameters, which are set to: (7.0, 8.0).
|...
|No first passage times recorded.
⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We used number <code>-99.9</code> just to remind ourselves that entries with this number need to be overwritten by parameters. There are however no rules or enforcements as to how the user deals with such entries.</p></div></div><p>Notice that trying to access <code>L</code> via <code>obs.L</code> will give you an incorrect result. To avoid such mistakes, always query <code>L</code>, <code>μ</code>,<code>Σ</code> and <code>obs</code> via accessors:</p><article class="docstring"><header><a class="docstring-binding" id="ObservationSchemes.L" href="#ObservationSchemes.L"><code>ObservationSchemes.L</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">L(o::LinearGsnObs)</code></pre><p>Return matrix L from the observation scheme ν = Lx+ξ, where ξ∼N(μ,Σ)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/ObservationSchemes.jl/blob/9a166f32b7a40369fed96c8a052bf9ec68648a64/src/observations_linear_gaussian.jl#LL116-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ObservationSchemes.μ" href="#ObservationSchemes.μ"><code>ObservationSchemes.μ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">μ(o::LinearGsnObs)</code></pre><p>Return vector μ from the observation scheme ν = Lx+ξ, where ξ∼N(μ,Σ)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/ObservationSchemes.jl/blob/9a166f32b7a40369fed96c8a052bf9ec68648a64/src/observations_linear_gaussian.jl#LL123-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ObservationSchemes.Σ" href="#ObservationSchemes.Σ"><code>ObservationSchemes.Σ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Σ(o::LinearGsnObs)</code></pre><p>Return matrix Σ from the observation scheme ν = Lx+ξ, where ξ∼N(μ,Σ)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/ObservationSchemes.jl/blob/9a166f32b7a40369fed96c8a052bf9ec68648a64/src/observations_linear_gaussian.jl#LL130-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ObservationSchemes.ν" href="#ObservationSchemes.ν"><code>ObservationSchemes.ν</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ν(o::Observation)</code></pre><p>Return the observation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/ObservationSchemes.jl/blob/9a166f32b7a40369fed96c8a052bf9ec68648a64/src/observations_linear_gaussian.jl#LL144-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ObservationSchemes.obs" href="#ObservationSchemes.obs"><code>ObservationSchemes.obs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">obs(o::Observation)</code></pre><p>Alias to ν. Return the observation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/ObservationSchemes.jl/blob/9a166f32b7a40369fed96c8a052bf9ec68648a64/src/observations_linear_gaussian.jl#LL151-L155">source</a></section></article><h2 id="Non-linear,-non-Gaussian-observations-1"><a class="docs-heading-anchor" href="#Non-linear,-non-Gaussian-observations-1">Non-linear, non-Gaussian observations</a><a class="docs-heading-anchor-permalink" href="#Non-linear,-non-Gaussian-observations-1" title="Permalink"></a></h2><hr/><p>In principle, any observation types are supported, but this comes at a cost of having to provide some information explicitly. The main struct for specifing general observation schemes is</p><article class="docstring"><header><a class="docstring-binding" id="ObservationSchemes.GeneralObs" href="#ObservationSchemes.GeneralObs"><code>ObservationSchemes.GeneralObs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct GeneralObs{Tag,D,T,FPT,K,Tlo,Tg,Td} &lt;: Observation{D,T}
    lin_obs::Tlo
    g::Tg
    dist::Td
    obs::T
    t::Float64
    θ::Vector{K}
end</code></pre><p>General observation of the underlying process that is of the form: g(x)+ξ, where ξ is distributed according to <code>dist</code>, <code>g</code> is a function specified externally, <code>obs</code> is the observation made at time <code>t</code>, <code>θ</code> is a container that may contain parameters and <code>lin_obs</code> is the approximation to this general observation scheme via the linearization with Gaussian noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiffusionBayes/ObservationSchemes.jl/blob/9a166f32b7a40369fed96c8a052bf9ec68648a64/src/observations_general.jl#LL1-L16">source</a></section></article><p>For this struct, the required parameters are the time of observation and the observation itself as well as the approximation via <code>LinearGsnObs</code>. For instance, to specify the following observational scheme:</p><div>\[V_t = g(X_t)+ξ\]</div><p>where ξ is distributed according to a bivariate <span>$T$</span>-distribution with <span>$4$</span> degrees of freedom, some specified mean <span>$\mu$</span> and covariance <span>$\Sigma$</span>, <span>$g$</span> is a non-linear function:</p><div>\[g(x):=
\left(
\begin{matrix}
(x^{[1]})^2\\
(x^{[2]})^2
\end{matrix}
\right)\]</div><p>we may write:</p><pre><code class="language-julia">using Distributions
# recording
t, v = 1.5, [1.0, 2.0]

# for the observation scheme
μ, Σ = [-1.0, 2.0], [1.0 0.0; 0.0 1.0]
dist = MvTDist(4, μ, Σ)
g(x) = view(x, 1:2).^2

# for some poor, ad-hoc Gaussian approximation
L = [2.0 0.0 0.0; 0.0 2.0 0.0]

# define observation
obs = GeneralObs(t, v, LinearGsnObs(t, v; L=L, Σ=Σ, μ=μ); dist=dist, g=g)</code></pre><p>We can now view the summary:</p><pre><code class="language-julia">julia&gt; summary(obs)
⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤
|Observation `v = g(x)+ξ`, where `g` is an operator defined by a function typeof(g), and `ξ` is a random variable given byDistributions.GenericMvTDist{Float64,PDMats.PDMat{Float64,Array{Float64,2}},Array{Float64,1}}.
|...
|| ν: [1.0, 2.0, 3.0] (observation),
||  → typeof(ν): SArray{Tuple{3},Float64,1,3},
|| made at time 2.0.
|...
|This is NOT an exact observation.
|...
|It does not depend on any additional parameters.
|...
|No first passage times recorded.
|...
|To inspect the linearized approximation to this observation scheme please type in:
|   summary(&lt;name-of-the-variable&gt;.lin_obs)
|and hit ENTER.
⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The <code>GeneralObs</code> can be decorated with first-passage time information and parameters in the same way as <code>LinearGsnObs</code> can. However, by design, you cannot set <code>full_obs</code> to <code>true</code> for <code>GeneralObs</code>.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../get_started/overview/">« Get started</a><a class="docs-footer-nextpage" href="../start_pt_prior/">Priors over starting points »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 2 June 2020 16:04">Tuesday 2 June 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
