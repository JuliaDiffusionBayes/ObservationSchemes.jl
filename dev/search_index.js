var documenterSearchIndex = {"docs":
[{"location":"module_index/#ObservationSchemes.jl-1","page":"Index","title":"ObservationSchemes.jl","text":"","category":"section"},{"location":"module_index/#","page":"Index","title":"Index","text":"","category":"page"},{"location":"module_index/#","page":"Index","title":"Index","text":"Modules = [ObservationSchemes]","category":"page"},{"location":"module_index/#ObservationSchemes.add_dependency!-Tuple{AllObservations,Dict}","page":"Index","title":"ObservationSchemes.add_dependency!","text":"add_dependency!(all_obs::AllObservations, dep::Dict)\n\nAdd a dependency structure dep between parameters shared across various laws and observations used to generate various recordings stored in an observations container all_obs.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.add_recording!-Tuple{AllObservations,NamedTuple}","page":"Index","title":"ObservationSchemes.add_recording!","text":"add_recording!(all_obs::AllObservations, recording::NamedTuple)\n\nAdd a new recording recording to an observations container all_obs.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.add_recordings!-Tuple{AllObservations,AbstractArray{#s22,N} where N where #s22<:NamedTuple}","page":"Index","title":"ObservationSchemes.add_recordings!","text":"add_recordings!(\n    all_obs::AllObservations,\n    recordings::AbstractArray{<:NamedTuple}\n)\n\nAdd multiple new recordings recordings to an observations container all_obs.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.build_recording-NTuple{4,Any}","page":"Index","title":"ObservationSchemes.build_recording","text":"build_recording(P, obs, t0, x0_prior)\n\nA utility function that creates an appropriate NamedTuple that represents a single recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.build_recording-Union{Tuple{K}, Tuple{Type{K},Any,Array{T,1} where T,Any,Any,Any}} where K","page":"Index","title":"ObservationSchemes.build_recording","text":"build_recording(\n    ::Type{K}, tt, observs::Vector, P, t0, x0_prior; kwargs...\n) where K\n\nA utility function for building a recording. Times of recordings are assumed to be stored in tt and their values in observs. K is the type of observation (for instance LinearGsnObs). kwargs are name arguments that are passed to every single initializer of K.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.fpt_info-Union{Tuple{LinearGsnObs{Tag,D,T,FPT,TL,Tμ,TΣ,K} where K where TΣ where Tμ where TL}, Tuple{FPT}, Tuple{T}, Tuple{D}, Tuple{Tag}} where FPT where T where D where Tag","page":"Index","title":"ObservationSchemes.fpt_info","text":"fpt_info(::LinearGsnObs{D,T,Tag,FPT}) where {D,T,Tag,FPT}\n\nReturn information about first-passage times\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.initialize-Tuple{AllObservations}","page":"Index","title":"ObservationSchemes.initialize","text":"initialize(all_obs::AllObservations)\n\nSplit the recordings at the times of full observations to make full use of the Markov property (and make the code readily parallelisable). Introduce all variable parameters that were not mentioned in the current dependency dictionary. Create internal dictionaries all_obs.param_depend_rev and all_obs.obs_depend_rev.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.load_data-Tuple{ObsScheme,Any,Any}","page":"Index","title":"ObservationSchemes.load_data","text":"load_data(os::ObsScheme, tt, xx)\n\nDecorate the data in xx and times of recordings in tt according to an observation scheme template stored in os.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.load_data-Tuple{ObsScheme,Any}","page":"Index","title":"ObservationSchemes.load_data","text":"load_data(os::ObsScheme, tt_xx)\n\nSame as load_data(os::ObsScheme, tt, xx), but tt_xx is a vector of tuples that pair the observations with their recorded times.\n\nload_data(os::ObsScheme, tt_xx_filename::String)\n\nSame as above, but tt_xx are stored in a .csv file named tt_xx_filename, with each row containing time t and its respective observation x stored back-to-back.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.print_parameters-Tuple{AllObservations}","page":"Index","title":"ObservationSchemes.print_parameters","text":"print_parameters(all_obs::AllObservations)\n\nPrint information about the variable parameters about which the all_obs.param_depend object stores some interdependency information.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.FirstPassageAbstract","page":"Index","title":"ObservationSchemes.FirstPassageAbstract","text":"FirstPassageAbstract\n\nTypes ihneriting from this struct define the type of information stored about first-passage times\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ObservationSchemes.ParametrizedObservation","page":"Index","title":"ObservationSchemes.ParametrizedObservation","text":"ParametrizedObservation{D,T} <: Observation{D,T}\n\nSame as observations but additionally, types inheriting from this struct depend on some parameters (that may in practice be unknown).\n\n\n\n\n\n","category":"type"},{"location":"module_index/#Base.eltype-Union{Tuple{Type{K}}, Tuple{K}, Tuple{T}, Tuple{D}} where K<:ObservationSchemes.Observation{D,T} where T where D","page":"Index","title":"Base.eltype","text":"eltype(::Type{K}) where {K<:Observation{D,T}}\n\nType of each entry of the collection holding an observation.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#Base.length-Union{Tuple{Type{K}}, Tuple{K}, Tuple{D}} where K<:(ObservationSchemes.Observation{D,T} where T) where D","page":"Index","title":"Base.length","text":"length(::Type{K}) where {K<:Observation{D}}\n\nLength of the observation (equal to a number of entries in a vector holding the data)\n\n\n\n\n\n","category":"method"},{"location":"module_index/#Base.rand","page":"Index","title":"Base.rand","text":"Base.rand(G::StartingPtPrior, [z, ρ=0.0])\n\nSample a new starting point according to its prior distribution. An implementation with arguments z, ρ implements a preconditioned Crank-Nicolson scheme with memory parameter ρ and a current non-centered variable z. z is also referred to as the driving noise.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#Base.rand","page":"Index","title":"Base.rand","text":"rand([rng::Random.AbstractRNG], G::GsnStartingPt, z, ρ=0.0)\n\nSample new white noise using Crank-Nicolson scheme with memory parameter ρ and a previous value of the white noise stored inside object G\n\n\n\n\n\n","category":"function"},{"location":"module_index/#Base.rand-Tuple{Random.AbstractRNG,GsnStartingPt}","page":"Index","title":"Base.rand","text":"rand([rng::Random.AbstractRNG], G::GsnStartingPt)\n\nSample new starting point according to its prior distribution.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#Base.rand-Tuple{Random.AbstractRNG,KnownStartingPt,Vararg{Any,N} where N}","page":"Index","title":"Base.rand","text":"rand([rng::Random.AbstractRNG], G::KnownStartingPt, args...)\n\nStarting point is known. Nothing can be sampled. Returning known starting point.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#Base.rand-Tuple{Random.AbstractRNG,LinearGsnObs,Any}","page":"Index","title":"Base.rand","text":"Base.rand([rng::Random.AbstractRNG], o::LinearGsnObs, X)\n\nSample an observation according to\n\nV  L X + ξquad mboxwhere  ξN(μΣ)\n\nwith L, μ and Σ defined in o.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#Base.size-Union{Tuple{Type{K}}, Tuple{K}, Tuple{D}} where K<:(ObservationSchemes.Observation{D,T} where T) where D","page":"Index","title":"Base.size","text":"size(::Type{K}) where {K<:Observation{D}}\n\nSize of the observation\n\n\n\n\n\n","category":"method"},{"location":"module_index/#Distributions.logpdf-Tuple{GsnStartingPt,Any}","page":"Index","title":"Distributions.logpdf","text":"logpdf(G::GsnStartingPt, y)\n\nlog-probability density function evaluated at y of a prior distribution G\n\n\n\n\n\n","category":"method"},{"location":"module_index/#Distributions.logpdf-Tuple{KnownStartingPt,Any}","page":"Index","title":"Distributions.logpdf","text":"logpdf(::KnownStartingPt, y)\n\nNothing to do so long as y is equal to the known starting point inside G\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.L-Tuple{LinearGsnObs}","page":"Index","title":"ObservationSchemes.L","text":"L(o::LinearGsnObs)\n\nReturn matrix L from the observation scheme ν = Lx+ξ, where ξ∼N(μ,Σ)\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes._prepare_xx-Tuple{Val{:simple},ObsScheme,Any}","page":"Index","title":"ObservationSchemes._prepare_xx","text":"_prepare_xx(::Val, os::ObsScheme, X)\n\nCycle through a collection X and transform it according to the observation schemes specified in os.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.check_recording_format-Union{Tuple{T}, Tuple{T}} where T<:NamedTuple","page":"Index","title":"ObservationSchemes.check_recording_format","text":"check_recording_format(::T) where T<:NamedTuple\n\nCheck whether the namedtuple has fields P, obs, t0 and x0_prior that each recording must have.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.fill_dependency_for_unspec_params_and_obs-Tuple{AllObservations}","page":"Index","title":"ObservationSchemes.fill_dependency_for_unspec_params_and_obs","text":"fill_dependency_for_unspec_params(all_obs::AllObservations)\n\nFill the all_obs.depen_param dictionary with all parameters that are not shared between recordings.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.inv_start_pt-Tuple{Any,GsnStartingPt,Any}","page":"Index","title":"ObservationSchemes.inv_start_pt","text":"inv_start_pt(y, G::GsnStartingPt, P)\n\nCompute the driving noise that is needed to obtain starting point y under prior G and the likelihood in P\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.inv_start_pt-Tuple{Any,KnownStartingPt,Any}","page":"Index","title":"ObservationSchemes.inv_start_pt","text":"inv_start_pt(y, G::KnownStartingPt, P)\n\nStarting point known, no need for dealing with white noise, use convention of returning y\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.local_symbols-Union{Tuple{T}, Tuple{AllObservations,AbstractArray{#s20,N} where N where #s20<:AbstractArray,Function,Array{Symbol,1}}} where T","page":"Index","title":"ObservationSchemes.local_symbols","text":"local_symbols(\n    all_obs::AllObservations,\n    objects::AbstractArray{<:AbstractArray},\n    f::Function,\n    θsym::Vector{Symbol}\n) where T\n\nobjects is usually an array of arrays that must in total have the same number of elements as there are observations in the recording. It may however have a different jagged structure. The output is of the same structure as objects and gives for each o in object a corresponding lists of parameters and observations it depends on.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.new_obs_dependence!-Tuple{Any,Any}","page":"Index","title":"ObservationSchemes.new_obs_dependence!","text":"new_obs_dependence!(old_dep, old_to_new_idx)\n\nCreate a new interdependency dictionary for the observations from the old one old_dep and the dictionary old_to_new_idx that kept track of the changes.\n\nExample\n\nold_dep = Dict(\n    :A => [(1, 2, 1), (1, 3, 2), (2, 1, 1)],\n    :B => [(2, 2, 2), (3, 2, 1)],\n)\nold_to_new_idx = Dict(\n    (1,1) => (1, 1), # obs (1,1) becomes (1,1)\n    (1,2) => (1, 2),\n    (1,3) => (2, 1), # obs (1,3) becomes (2,1)\n    (2,1) => (3, 1),\n    (2,2) => (4, 1),\n    (2,3) => (5, 1),\n    (3,1) => (6, 1),\n    (3,2) => (6, 2),\n)\n\nnew_dep = new_obs_dependence!(old_dep, old_to_new_idx)\n\nnew_dep == Dict(\n    :A => [(1, 2, 1), (2, 1, 2), (3, 1, 1)],\n    :B => [(4, 1, 2), (6, 2, 1)]\n)\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.new_param_and_obs_dependence!-NTuple{5,Any}","page":"Index","title":"ObservationSchemes.new_param_and_obs_dependence!","text":"new_param_and_obs_dependence!(\n    out,\n    old_p_dep,\n    old_o_dep,\n    old_to_new_idx,\n    old_to_new_obs_idx\n)\n\nTODO refresh Define a new parameter dependence structure by using an old parameter dependence saved in old_dep and deducing the changed indices of affected recording by following the old_to_new_idx dictionary. The new dependency is saved directly to out structure.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.new_param_dependence!-Tuple{Any,Any}","page":"Index","title":"ObservationSchemes.new_param_dependence!","text":"new_param_dependence!(old_dep, old_to_new_idx)\n\nCreate a new interdependency dictionary for the parameters from the old one old_dep and the dictionary old_to_new_idx that kept track of the changes.\n\nExamples\n\nold_dep = Dict(\n    :A => [(1, :a), (2, :a1)],\n    :B => [(1, :b), (3, :bbb)],\n)\nold_to_new_idx = Dict(\n    1 => [1, 2], # observation 1 was split into two\n    2 => [3, 4, 5], # observation 2 was split into three\n    3 => [6],\n)\n\nnew_dep = new_param_dependence!(old_dep, old_to_new_idx)\n\nnew_dep == Dict(\n    :A => [1=>:a, 2=>:a, 3=>:a1, 4=>:a1, 5=>:a1],\n    :B => [1=>:b, 2=>:b, 6=>:bbb],\n)\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.parameter_names","page":"Index","title":"ObservationSchemes.parameter_names","text":"parameter_names\n\nReturn names of the parameters of a given object\n\n\n\n\n\n","category":"function"},{"location":"module_index/#ObservationSchemes.split_recording!-Tuple{Any,Any,Any,AllObservations,Any,Any}","page":"Index","title":"ObservationSchemes.split_recording!","text":"split_recording!(\n        recording_idx,\n        recording,\n        counter,\n        out::AllObservations,\n        old_to_new_idx,\n        old_to_new_obs_idx,\n    )\n\nSplit a single record recording at the times of full observations. Save new, splitted recordings in the struct out. Keep account of the changed indices of the recordings for the recording index <---> parameter dependence pairs by updating a suitable dictionary old_to_new_idx, starting the new recording's index at an offset counter.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.start_pt-Tuple{Any,GsnStartingPt,Any}","page":"Index","title":"ObservationSchemes.start_pt","text":"start_pt(z, G::GsnStartingPt, P)\n\nCompute a new starting point from the white noise for a given posterior distribution obtained from combining prior G and the likelihood encoded by the object P.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.start_pt-Tuple{Any,GsnStartingPt}","page":"Index","title":"ObservationSchemes.start_pt","text":"start_pt(z, G::GsnStartingPt)\n\nCompute a new starting point from the white noise for a given prior distribution G\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.start_pt-Tuple{Any,KnownStartingPt,Any}","page":"Index","title":"ObservationSchemes.start_pt","text":"start_pt(z, G::KnownStartingPt, P)\n\nReturn starting point\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.start_pt-Tuple{KnownStartingPt,Any}","page":"Index","title":"ObservationSchemes.start_pt","text":"start_pt(G::KnownStartingPt, P)\n\nReturn starting point\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.Λ-Tuple{LinearGsnObs}","page":"Index","title":"ObservationSchemes.Λ","text":"Λ(o::LinearGsnObs)\n\nReturn matrix Λ:=Σ⁻¹ from the observation scheme ν = Lx+ξ, where ξ∼N(μ,Σ)\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.Σ-Tuple{LinearGsnObs}","page":"Index","title":"ObservationSchemes.Σ","text":"Σ(o::LinearGsnObs)\n\nReturn matrix Σ from the observation scheme ν = Lx+ξ, where ξ∼N(μ,Σ)\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.μ-Tuple{LinearGsnObs}","page":"Index","title":"ObservationSchemes.μ","text":"μ(o::LinearGsnObs)\n\nReturn vector μ from the observation scheme ν = Lx+ξ, where ξ∼N(μ,Σ)\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.ν-Tuple{ObservationSchemes.Observation}","page":"Index","title":"ObservationSchemes.ν","text":"ν(o::Observation)\n\nReturn the observation\n\n\n\n\n\n","category":"method"},{"location":"get_started/overview/#get_started-1","page":"Get started","title":"Get started","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#Installation-1","page":"Get started","title":"Installation","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"The package is not registered yet. To install it write:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"] add https://github.com/JuliaDiffusionBayes/ObservationSchemes.jl","category":"page"},{"location":"get_started/overview/#A-single-observation-1","page":"Get started","title":"A single observation","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"To define a single observation collected according to","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"V_t = LX_t+ξquad ξ  N(μΣ)","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"use LinearGsnObs, for instance","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"ν = [1.0, 2.0, 3.0]\nt = 2.0\nL = [1.0 0.0 2.0 0.0; 3.0 4.0 0.0 0.0; 0.0 1.0 0.0 1.0]\nΣ = Diagonal([1.0, 1.0, 1e-11])\nobs = LinearGsnObs(t, ν; L = L, Σ = Σ) # μ defaults to 0","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"To view some summary information call:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"julia> summary(obs)\n⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤\n|Observation `v = Lx+ξ`, where `L` is a (3, 4)-matrix, `x` is a state of the stochastic process and `ξ`∼N(μ,Σ).\n|...\n|| ν: [1.0, 2.0, 3.0] (observation),\n||  → typeof(ν): Array{Float64,1},\n|| made at time 2.0.\n|...\n|L: [1.0 0.0 2.0 0.0; 3.0 4.0 0.0 0.0; 0.0 1.0 0.0 1.0],\n|   → typeof(L): Array{Float64,2}\n|μ: [0.0, 0.0, 0.0],\n|   → typeof(μ): Array{Float64,1}\n|Σ: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0e-11],\n|   → typeof(Σ): Diagonal{Float64,Array{Float64,1}}\n|...\n|This is NOT an exact observation.\n|...\n|It does not depend on any additional parameters.\n|...\n|No first passage times recorded.\n⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"For a general observation scheme:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"V_t = g(X_t) + ξquad ξ  Ξ","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"you may use GeneralObs instead of LinearGsnObs, but you must provide the function g, the law Xi (and an approximation via LinearGsnObs if you wish to use it with other packages in JuliaDiffusionBayes).","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"Additionally, first passage time observations are supported.","category":"page"},{"location":"get_started/overview/#Multiple-observations-1","page":"Get started","title":"Multiple observations","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"To define multiple observations at once define a list of observation formats in which the data was collected:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"# type 1\nt, v = 1.0, [1.0, 2.0, 3.0] # dummy values, only their DataTypes matter\nobs = LinearGsnObs(t, v; full_obs=true)\n\n# type 2, i.e. another observation scheme:\nt, v = 1.0, [1.0]\nobs2 = LinearGsnObs(t, v; L=[1.0 0.0 0.0;], Σ = reshape([1.0], (1,1)))\n\n# data defined externally:\ntt, xx = ...\n\n# template of an observation scheme in pattern: obs, obs2, obs, obs2, obs, ...\nobs_scheme = ObsScheme(obs, obs2; pattern=[1,2])\n\n# decorate the data\nobservs = load_data(obs_scheme, tt, xx)","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"You can even collect your data directly from the simulated trajectory using ObsScheme:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"# simulate some data\nusing DiffusionDefinition\n@load_diffusion Lorenz\nθ = [10.0, 28.0, 8.0/3.0, 1.0]\nP = Lorenz(θ...)\ntt, y1 = 0.0:0.001:10.0, @SVector [-10.0, -10.0, 25.0]\nX = rand(P, tt, y1)\n\n# collect the data and decorate\nobservs = collect(\n    obs_scheme, X,\n    1000, # 1 in every 1000 points collected\n    true, # omit the starting pt\n)","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"Inspecting the first two elements of observs reveals:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"julia> summary(observs[1])\n⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤\n|Observation `v = Lx+ξ`, where `L` is a (3, 3)-matrix, `x` is a state of the stochastic process and `ξ`∼N(μ,Σ).\n|...\n|| ν: [-6.973713465241107, -7.078798675212648, 25.333374615535917] (observation),\n||  → typeof(ν): Array{Float64,1},\n|| made at time 1.0.\n|...\n|L: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0],\n|   → typeof(L): Diagonal{Float64,Array{Float64,1}}\n|μ: [0.0, 0.0, 0.0],\n|   → typeof(μ): Array{Float64,1}\n|Σ: [1.0e-11 0.0 0.0; 0.0 1.0e-11 0.0; 0.0 0.0 1.0e-11],\n|   → typeof(Σ): Diagonal{Float64,Array{Float64,1}}\n|...\n|This is an exact observation.\n|...\n|It does not depend on any additional parameters.\n|...\n|No first passage times recorded.\n⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆\n\njulia> summary(observs[2])\n⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤\n|Observation `v = Lx+ξ`, where `L` is a (1, 3)-matrix, `x` is a state of the stochastic process and `ξ`∼N(μ,Σ).\n|...\n|| ν: [-8.536161659220804] (observation),\n||  → typeof(ν): Array{Float64,1},\n|| made at time 2.0.\n|...\n|L: [1.0 0.0 0.0],\n|   → typeof(L): Array{Float64,2}\n|μ: [0.0],\n|   → typeof(μ): Array{Float64,1}\n|Σ: [1.0],\n|   → typeof(Σ): Array{Float64,2}\n|...\n|This is NOT an exact observation.\n|...\n|It does not depend on any additional parameters.\n|...\n|No first passage times recorded.\n⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"The decorated observations of a trajectory may now be put inside a container that collects observations of multiple trajectories:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"all_obs = AllObservations()\nadd_recording!(\n    all_obs,\n    (\n        P = P, # this is some target law of the stochastic process\n        obs = observs,\n        t0 = 0.0, # starting time\n        x0_prior = KnownStartingPt([1.0, 2.0]), # prior over the starting position\n    )\n)","category":"page"},{"location":"get_started/overview/#Define-interdependence-structure-for-parameters-1","page":"Get started","title":"Define interdependence structure for parameters","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"If your data consist of recordings of multiple trajectories, sampled under laws that share some subsets of parameters or observation schemes sharing some parameters, then you may wish to add all of them to AllObservations above and then specify the interdependence structure of parameters. To this end you may use add_dependency! function.","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"For instance, to specify that the first and second recording share dependence on two common parameters (one of which under the law of recording 1 is encoded as α1 and under the law of recording 2 is encoded as α2 and another one, which under both recording is encoded as :β) we may write","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"add_dependency!(\n    all_obs,\n    Dict(\n        :α_shared => [(1, :α1), (2, :α1) #= format: (idx-of-recording, param-name) =#],\n        :β_shared => [(1, :β), (2, :β)],\n    )\n)","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"Once you're done setting up an instance of AllObservations call initialize to complete initialization.","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"initialised_all_obs, old_to_new_idx = initialize(all_obs)","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"The object initialised_all_obs will now contain all necessary information about how the data were collected, everything that is known about the underlying process that generated it, as well as the data themselves.","category":"page"},{"location":"manual/single_observation/#manual_start-1","page":"A single observation","title":"Observation schemes","text":"","category":"section"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"All observation schemes inherit from","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"ObservationSchemes.Observation","category":"page"},{"location":"manual/single_observation/#ObservationSchemes.Observation","page":"A single observation","title":"ObservationSchemes.Observation","text":"Observation{D,T}\n\nTypes inheriting from this struct provide all information about the observation of the stochastic process being made. D denotes the dimension of the observation whereas T its eltype.\n\n\n\n\n\n","category":"type"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"which has methods","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"ObservationSchemes.eltype\nObservationSchemes.size\nObservationSchemes.length","category":"page"},{"location":"manual/single_observation/#Base.eltype","page":"A single observation","title":"Base.eltype","text":"eltype(::Type{K}) where {K<:Observation{D,T}}\n\nType of each entry of the collection holding an observation.\n\n\n\n\n\n","category":"function"},{"location":"manual/single_observation/#Base.size","page":"A single observation","title":"Base.size","text":"size(::Type{K}) where {K<:Observation{D}}\n\nSize of the observation\n\n\n\n\n\n","category":"function"},{"location":"manual/single_observation/#Base.length","page":"A single observation","title":"Base.length","text":"length(::Type{K}) where {K<:Observation{D}}\n\nLength of the observation (equal to a number of entries in a vector holding the data)\n\n\n\n\n\n","category":"function"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"automatically implemented for it. The idea is to decorate each recorded data-point with such structs, and in doing so, encode the way in which it was collected.","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"We implemented two concrete structs that may be used for defining a single observation:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"LinearGsnObs: to encode observations of the linear transformations of the underlying process disturbed by Gaussian noise\nGeneralObs: to encode observations of non-linear transformations of the underlying process disturbed by noise.","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"Both admit a possibility of parameterization.","category":"page"},{"location":"manual/single_observation/#Linear-Gaussian-struct-1","page":"A single observation","title":"Linear Gaussian struct","text":"","category":"section"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"The most important observation scheme is LinearGsnObs.  It is suitable for representing observations that can be written in the following format:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"beginequationlabeleqobs_scheme\nV_t = LX_t+xiquad xisim N(μΣ)\nendequation","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"where LinRR^dtimes d and X_t is a state of the underlying stochastic process.","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"ObservationSchemes.LinearGsnObs","category":"page"},{"location":"manual/single_observation/#ObservationSchemes.LinearGsnObs","page":"A single observation","title":"ObservationSchemes.LinearGsnObs","text":"struct LinearGsnObs{Tag,D,T,FPT,S,R,K} <: Observation{D,T}\n    L::S\n    μ::T\n    Σ::R\n    obs::T\n    t::Float64\n    full_obs::Bool\n    θ::Vector{K}\nend\n\nObservation of the underlying process that is of the form:\n\nLX+ξquadmboxwhere ξN(μΣ)\n\nand LinmathbbR^Dd, ΣinmathbbR^DD and μinmathbbR^D, with d0 the dimension of the underlying process X. FPT stores information about first-passage times. full_obs is an indicator for whether it is a full observation of the process (as it grants the use of Markov Property). θ is a container that may contain parameters that enter L, μ and Σ, whereas Tag is a disambiguation flag used at compile time or for multiple dispatch to differentiate between different observation types.\n\nfunction LinearGsnObs(\n    t,\n    obs::T;\n    L=_default_L(obs), # defaults to I\n    Σ=_default_Σ(obs), # defaults to ϵI, with ϵ=1e-11\n    μ=_default_μ(obs), # defaults to 0 vector\n    fpt=NoFirstPassageTimes(),\n    full_obs=false,\n    Tag=0,\n    θ=[],\n) where T\n\nBase constructor of LinearGsnObs. t is the time of the observation and obs is the actual observation. The remaining, named parameters are self-explanatory.\n\n\n\n\n\n","category":"type"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"Below, we list some special cases of the scheme above.","category":"page"},{"location":"manual/single_observation/#Exact-observations-of-the-process-1","page":"A single observation","title":"Exact observations of the process","text":"","category":"section"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"A degenerate case of the setting above is an exact observation of X_t, i.e. when","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"L = I_dqquad μ = 0_dtimes 1qquad Σ = 0_dtimes d","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"so that X_t=V_t. This can be defined as:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"t, v = 1.0, [1.0, 2.0, 3.0]\nobs = LinearGsnObs(t, v; full_obs=true)","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"warning: Warning\nFor numerical reasons the covariance matrix of the noise Σ should not be a zero matrix, and instead, even in the exact observation setting should be inflated by some small artificial noise. By default Σ is set to Sigma=10^-11I_d for numerical reasons. This can be changed by specifying Σ explicitly, for instance to increase the level of artificial noise:using LinearAlgebra\nobs = LinearGsnObs(t, v; Σ=(1e-5)I, full_obs=true)","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"Specifying full_obs=true is important, as it lets the compiler differentiate between an actual, full observation with some artificial noise and a (possibly) partial observation with very low level (or also artificial level) of noise. As a result, other packages from JuliaDiffusionBayes know when the Markov property can be applied.","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"We can view a summary of the observation by calling summary:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"julia> summary(obs)\n⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤\n|Observation `v = Lx+ξ`, where `L` is a (3, 3)-matrix, `x` is a state of the stochastic process and `ξ`∼N(μ,Σ).\n|...\n|| v: [1.0, 2.0, 3.0] (observation),\n||  → typeof(v): Array{Float64,1},\n|| made at time 1.0.\n|...\n|L: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0],\n|   → typeof(L): Diagonal{Float64,Array{Float64,1}}\n|μ: [0.0, 0.0, 0.0],\n|   → typeof(μ): Array{Float64,1}\n|Σ: [1.0e-11 0.0 0.0; 0.0 1.0e-11 0.0; 0.0 0.0 1.0e-11],\n|   → typeof(Σ): Diagonal{Float64,Array{Float64,1}}\n|...\n|This is an exact observation.\n|...\n|It does not depend on any additional parameters.\n|...\n|No first passage times recorded.\n⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"Notice that various defaults and type-inferences have kicked in. It was recognized that the observation does not depend on any parameters, that first-passage time setting does not apply and that the observation was not of a static type and hence regular Arrays are used to define L, μ and Σ.","category":"page"},{"location":"manual/single_observation/#standard_example_lingsnobs-1","page":"A single observation","title":"Linear transformations of the process disturbed by Gaussian noise","text":"","category":"section"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"This is a standard understanding of the expression in \\eqref{eq:obs_scheme}. An example could be:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"using StaticArrays\nv = @SVector [1.0, 2.0, 3.0]\nt = 2.0\nL = @SMatrix [1.0 0.0 2.0 0.0; 3.0 4.0 0.0 0.0; 0.0 1.0 0.0 1.0]\nΣ = SDiagonal(1.0, 1.0, 1e-11)\nobs = LinearGsnObs(t, v; L = L, Σ = Σ)","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"for defining a three-dimensional observation v made at time 20 of a four-dimensional process X, where the first coordinate of the observation is X_t^1+2X_t^3+ξ^1, with ξ^1  N(01), the second coordinate is 3X_t^1+4X_t^2+ξ^2, with ξ^2  N(01), and the third coordinate is X_t^2+X_t^4, with no real noise (only artificial one, needed for numerical reasons). We can display the summary of the observation with:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"julia> summary(obs)\n⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤\n|Observation `v = Lx+ξ`, where `L` is a (3, 4)-matrix, `x` is a state of the stochastic process and `ξ`∼N(μ,Σ).\n|...\n|| v: [1.0, 2.0, 3.0] (observation),\n||  → typeof(v): SArray{Tuple{3},Float64,1,3},\n|| made at time 2.0.\n|...\n|L: [1.0 0.0 2.0 0.0; 3.0 4.0 0.0 0.0; 0.0 1.0 0.0 1.0],\n|   → typeof(L): SArray{Tuple{3,4},Float64,2,12}\n|μ: [0.0, 0.0, 0.0],\n|   → typeof(μ): SArray{Tuple{3},Float64,1,3}\n|Σ: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0e-11],\n|   → typeof(Σ): Diagonal{Float64,SArray{Tuple{3},Float64,1,3}}\n|...\n|This is NOT an exact observation.\n|...\n|It does not depend on any additional parameters.\n|...\n|No first passage times recorded.\n⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"Note that the internal containers are now set to be SVectors (even μ, which wasn't passed to a constructor but its type was inferred and its value set to zero). Additionally, Julia understands that this is not a full observation and hence Markov property cannot be applied.","category":"page"},{"location":"manual/single_observation/#first_passage_time-1","page":"A single observation","title":"First-passage time observations","text":"","category":"section"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"Support for certain first-passage time settings is provided. By default LinearGsnObs sets the information about the first-passage times to","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"ObservationSchemes.NoFirstPassageTimes","category":"page"},{"location":"manual/single_observation/#ObservationSchemes.NoFirstPassageTimes","page":"A single observation","title":"ObservationSchemes.NoFirstPassageTimes","text":"NoFirstPassageTimes <: FirstPassageAbstract\n\nCompile-time indicator that the observation stores no first-passage time data\n\n\n\n\n\n","category":"type"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"However, this can be changed by passing appropriately initialized","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"ObservationSchemes.FirstPassageTimeInfo","category":"page"},{"location":"manual/single_observation/#ObservationSchemes.FirstPassageTimeInfo","page":"A single observation","title":"ObservationSchemes.FirstPassageTimeInfo","text":"FirstPassageTimeInfo{C,L,U,A,R} <: FirstPassageAbstract\n\nCompile-time indicator for the first-passage time information conveyed by the data-point. C lists the affected coordinates (of the observations, not the process), L indicates the level, U are indicators for whether the respective first-passage times are up-crossings and A is and indicator for whether an additional reset needs to be reached before first-passage time (note that reset time is defined as a first-passage time to a corresponding reset level stored in R that happens anytime before the actual first-passage time, the reset-time happens in the direction opposite to the direction of first-passage time crossing; additionally, the coordinate can reach the first-passage time level prior to being reset).\n\nFirstPassageTimeInfo(\n    coords,\n    levels,\n    upcrossings,\n    additional_reset_required,\n    reset_levels=tuple()\n)\n\nBase constructor.\n\n\n\n\n\n","category":"type"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"For instance, to indicate in the example above that the last coordinate of v actually reaches level 30 for the very first time at time 10 we can specify the following:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"t, v = 1.0, [1.0, 2.0, 3.0]\nfpt = FirstPassageTimeInfo(\n    (3,),\n    (3.0,),\n    (true,),\n    (false,),\n    (),\n)\nobs = LinearGsnObs(t, v; L = L, Σ = Σ, fpt = fpt)","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"The last two entries in fpt specify additional reset times. For instance, instead of (false,) and () we could set (true,), (-1.0) to indicate that the process X_t^2+X_t^4 can do whatever before it falls below level -10 (in particular it can go above level 30), and that once it falls below -10, then from then on the first time it reaches level 30 happens at time 10. Note that","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"julia> summary(obs)\n⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤\n|Observation `v = Lx+ξ`, where `L` is a (3, 4)-matrix, `x` is a state of the stochastic process and `ξ`∼N(μ,Σ).\n|...\n|| v: [1.0, 2.0, 3.0] (observation),\n||  → typeof(v): Array{Float64,1},\n|| made at time 1.0.\n|...\n|L: [1.0 0.0 2.0 0.0; 3.0 4.0 0.0 0.0; 0.0 1.0 0.0 1.0],\n|   → typeof(L): SArray{Tuple{3,4},Float64,2,12}\n|μ: [0.0, 0.0, 0.0],\n|   → typeof(μ): Array{Float64,1}\n|Σ: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0e-11],\n|   → typeof(Σ): Diagonal{Float64,SArray{Tuple{3},Float64,1,3}}\n|...\n|This is NOT an exact observation.\n|...\n|It does not depend on any additional parameters.\n|...\n|First passage times of the observation `v`:\n|----------------------------------------------------------------------------\n||  coordinate  |     level    |  up-crossing |  extra reset |  reset level |\n|----------------------------------------------------------------------------\n||       3      |      3.0     |  up-crossing |       ✘      |       ✘      |\n⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"changes appropriately to display the new summary of the first-passage time information.","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"note: Note\nThis package is agnostic with respect to the algorithms that are later used on the decorated observations. Consequently it doesn't make any checks for whether the observations make sense. For instance in the package GuidedProposals.jl that deals with simulating conditioned diffusions, a support for first-passage time observations is currently extended only to diffusions  where the dynamics of the coordinate whose first-passage time is observed is devoid of any Wiener noise. The onus of checking whether this or other constraints are satisfied are on the user.","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"tip: Why do we refer to `LinearGsnObs` as most important?\nIn practice, all other observation schemes are handled by other packages in JuliaDiffusionBayes by approximating them with a suitable LinearGsnObs and then correcting the resulting approximation error with the Metropolis-Hastings algorithm. Consequently, LinearGsnObs will be a building block of any other observation scheme.","category":"page"},{"location":"manual/single_observation/#Parameterizing-LinearGsnObs-1","page":"A single observation","title":"Parameterizing LinearGsnObs","text":"","category":"section"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"The observations can be parameterized by passing a vector of parameters θ. Additionally, a Tag needs to be attached that is used to differentiate at compile time between the non-parameterized observations and parameterized observations as well as among different parameterizations themselves.","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"For instance, to indicate in the second example that two entries in the L matrix are parameterized we can write:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"v = @SVector [1.0, 2.0, 3.0]\nt = 2.0\nL = @SMatrix [1.0 0.0 -99.9 0.0; 3.0 4.0 0.0 0.0; 0.0 -99.9 0.0 1.0]\nΣ = SDiagonal(1.0, 1.0, 1e-11)\nobs = LinearGsnObs(t, v; L = L, Σ = Σ, θ=[2.0, 1.0], Tag=1)","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"We are not done yet, in this case matrix L that we passed above is incomplete as we intend to create an actual matrix L by combining the matrix and the parameters we've passed. To this end, we must overwrite the behaviour of the function L(⋅):","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"const OBS = ObservationSchemes\nfunction OBS.L(o::LinearGsnObs{1})\n    _L = MMatrix{3,4,Float64}(o.L)\n    _L[1,3] = o.θ[1]\n    _L[3,2] = o.θ[2]\n    SMatrix{3,4,Float64}(_L)\nend","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"Notice that we dispatch on the observation's tag 1. Furthermore, when calling summarize matrix L is displayed correctly.","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"julia> summary(obs)\n⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤\n|Observation `v = Lx+ξ`, where `L` is a (3, 4)-matrix, `x` is a state of the stochastic process and `ξ`∼N(μ,Σ).\n|...\n|| ν: [1.0, 2.0, 3.0] (observation),\n||  → typeof(ν): SArray{Tuple{3},Float64,1,3},\n|| made at time 2.0.\n|...\n|L: [1.0 0.0 2.0 0.0; 3.0 4.0 0.0 0.0; 0.0 1.0 0.0 1.0],\n|   → typeof(L): SArray{Tuple{3,4},Float64,2,12}\n|μ: [0.0, 0.0, 0.0],\n|   → typeof(μ): SArray{Tuple{3},Float64,1,3}\n|Σ: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0e-11],\n|   → typeof(Σ): Diagonal{Float64,SArray{Tuple{3},Float64,1,3}}\n|...\n|This is NOT an exact observation.\n|...\n|It depends on additional parameters, which are set to: (2.0, 1.0).\n|...\n|No first passage times recorded.\n⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"However, now we can change parameters to new values and the matrix L will be updated:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"OBS.update_params!(obs, [7.0, 8.0])\njulia> summary(obs)\n⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤\n|Observation `v = Lx+ξ`, where `L` is a (3, 4)-matrix, `x` is a state of the stochastic process and `ξ`∼N(μ,Σ).\n|...\n|| ν: [1.0, 2.0, 3.0] (observation),\n||  → typeof(ν): SArray{Tuple{3},Float64,1,3},\n|| made at time 2.0.\n|...\n|L: [1.0 0.0 7.0 0.0; 3.0 4.0 0.0 0.0; 0.0 8.0 0.0 1.0],\n|   → typeof(L): SArray{Tuple{3,4},Float64,2,12}\n|μ: [0.0, 0.0, 0.0],\n|   → typeof(μ): SArray{Tuple{3},Float64,1,3}\n|Σ: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0e-11],\n|   → typeof(Σ): Diagonal{Float64,SArray{Tuple{3},Float64,1,3}}\n|...\n|This is NOT an exact observation.\n|...\n|It depends on additional parameters, which are set to: (7.0, 8.0).\n|...\n|No first passage times recorded.\n⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"note: Note\nWe used number -99.9 just to remind ourselves that entries with this number need to be overwritten by parameters. There are however no rules or enforcements as to how the user deals with such entries.","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"Notice that trying to access L via obs.L will give you an incorrect result. To avoid such mistakes, always query L, μ,Σ and obs via accessors:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"ObservationSchemes.L\nObservationSchemes.μ\nObservationSchemes.Σ\nObservationSchemes.ν\nObservationSchemes.obs","category":"page"},{"location":"manual/single_observation/#ObservationSchemes.L","page":"A single observation","title":"ObservationSchemes.L","text":"L(o::LinearGsnObs)\n\nReturn matrix L from the observation scheme ν = Lx+ξ, where ξ∼N(μ,Σ)\n\n\n\n\n\n","category":"function"},{"location":"manual/single_observation/#ObservationSchemes.μ","page":"A single observation","title":"ObservationSchemes.μ","text":"μ(o::LinearGsnObs)\n\nReturn vector μ from the observation scheme ν = Lx+ξ, where ξ∼N(μ,Σ)\n\n\n\n\n\n","category":"function"},{"location":"manual/single_observation/#ObservationSchemes.Σ","page":"A single observation","title":"ObservationSchemes.Σ","text":"Σ(o::LinearGsnObs)\n\nReturn matrix Σ from the observation scheme ν = Lx+ξ, where ξ∼N(μ,Σ)\n\n\n\n\n\n","category":"function"},{"location":"manual/single_observation/#ObservationSchemes.ν","page":"A single observation","title":"ObservationSchemes.ν","text":"ν(o::Observation)\n\nReturn the observation\n\n\n\n\n\n","category":"function"},{"location":"manual/single_observation/#ObservationSchemes.obs","page":"A single observation","title":"ObservationSchemes.obs","text":"obs(o::Observation)\n\nAlias to ν. Return the observation.\n\n\n\n\n\n","category":"function"},{"location":"manual/single_observation/#non_linear_non_gsn-1","page":"A single observation","title":"Non-linear, non-Gaussian observations","text":"","category":"section"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"In principle, any observation types are supported, but this comes at a cost of having to provide some information explicitly. The main struct for specifing general observation schemes is","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"ObservationSchemes.GeneralObs","category":"page"},{"location":"manual/single_observation/#ObservationSchemes.GeneralObs","page":"A single observation","title":"ObservationSchemes.GeneralObs","text":"struct GeneralObs{Tag,D,T,FPT,K,Tlo,Tg,Td} <: Observation{D,T}\n    lin_obs::Tlo\n    g::Tg\n    dist::Td\n    obs::T\n    t::Float64\n    θ::Vector{K}\nend\n\nGeneral observation of the underlying process that is of the form:\n\ng(x)+ξ\n\nwhere ξ is distributed according to dist, g (corresponding to passed g) is a function specified externally, obs is the observation made at time t, θ is a container that may contain parameters and lin_obs is the approximation to this general observation scheme via the linearization with Gaussian noise.\n\nGeneralObs(\n    t,\n    obs,\n    linearization;\n    dist=_default_dist(obs),\n    g=identity,\n    fpt=NoFirstPassageTimes(),\n    Tag=0,\n    θ=[],\n)\n\nBase constructor.\n\n\n\n\n\n","category":"type"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"For this struct the required parameters are the time at which the observation was recorded and the observation itself, as well as the approximation via LinearGsnObs. For instance, to specify the following observational scheme:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"V_t = g(X_t)+ξ","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"where ξ is distributed according to a bivariate T-distribution with 4 degrees of freedom, some specified mean μ and covariance Σ, g is given by the following non-linear function:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"g(x)=\nleft(\n    beginmatrix\n        (x^1)^2\n        (x^2)^2\n    endmatrix\nright)","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"we may write:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"using Distributions\n# recording\nt, v = 1.5, [1.0, 2.0]\n\n# for the observation scheme\nμ, Σ = [-1.0, 2.0], [1.0 0.0; 0.0 1.0]\ndist = MvTDist(4, μ, Σ)\ng(x) = view(x, 1:2).^2\n\n# for some poor, ad-hoc Gaussian approximation\nL = [2.0 0.0 0.0; 0.0 2.0 0.0]\n\n# define observation\nobs = GeneralObs(t, v, LinearGsnObs(t, v; L=L, Σ=Σ, μ=μ); dist=dist, g=g)","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"We can now view the summary:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"julia> summary(obs)\n⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤\n|Observation `v = g(x)+ξ`, where `g` is an operator defined by a function typeof(g), and `ξ` is a random variable given byDistributions.GenericMvTDist{Float64,PDMats.PDMat{Float64,Array{Float64,2}},Array{Float64,1}}.\n|...\n|| ν: [1.0, 2.0, 3.0] (observation),\n||  → typeof(ν): SArray{Tuple{3},Float64,1,3},\n|| made at time 2.0.\n|...\n|This is NOT an exact observation.\n|...\n|It does not depend on any additional parameters.\n|...\n|No first passage times recorded.\n|...\n|To inspect the linearized approximation to this observation scheme please type in:\n|   summary(<name-of-the-variable>.lin_obs)\n|and hit ENTER.\n⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"tip: Tip\nThe GeneralObs can be decorated with first-passage time information and parameters in the same way as LinearGsnObs can. However, by design, you cannot set full_obs to true for GeneralObs.","category":"page"},{"location":"how_to_guides/save_to_files/#How-to-save-decorated-data-to-a-file?-1","page":"... save decorated data to a file?","title":"How to save decorated data to a file?","text":"","category":"section"},{"location":"how_to_guides/save_to_files/#","page":"... save decorated data to a file?","title":"... save decorated data to a file?","text":"","category":"page"},{"location":"how_to_guides/save_to_files/#","page":"... save decorated data to a file?","title":"... save decorated data to a file?","text":"A convenient way to save decorate data to a file is to use the package JuliaDB.jl.","category":"page"},{"location":"how_to_guides/save_to_files/#","page":"... save decorated data to a file?","title":"... save decorated data to a file?","text":"Once you've decorated your data, simply create a JuliaDB table:","category":"page"},{"location":"how_to_guides/save_to_files/#","page":"... save decorated data to a file?","title":"... save decorated data to a file?","text":"dec_data = ...\n\nusing JuliaDB\n\nt = table(1:length(dec_data), dec_data, pkey=1)","category":"page"},{"location":"how_to_guides/save_to_files/#","page":"... save decorated data to a file?","title":"... save decorated data to a file?","text":"and save it to the disk","category":"page"},{"location":"how_to_guides/save_to_files/#","page":"... save decorated data to a file?","title":"... save decorated data to a file?","text":"save(t, \"path/to/destination/filename.db\")","category":"page"},{"location":"how_to_guides/save_to_files/#","page":"... save decorated data to a file?","title":"... save decorated data to a file?","text":"Your file will contain decorated data i.e. complete information about the underlying process and how the data was collected together with the data themselves will be in that file–no need for having to specify anything else externally.","category":"page"},{"location":"how_to_guides/save_to_files/#","page":"... save decorated data to a file?","title":"... save decorated data to a file?","text":"You can then load the data back in with","category":"page"},{"location":"how_to_guides/save_to_files/#","page":"... save decorated data to a file?","title":"... save decorated data to a file?","text":"t = load(\"path/to/destination/filename.db\")","category":"page"},{"location":"how_to_guides/simple_os/#simple_observation_schemes-1","page":"... ergonomically deal with simple observation schemes?","title":"How to ergonomically deal with simple observation schemes?","text":"","category":"section"},{"location":"how_to_guides/simple_os/#","page":"... ergonomically deal with simple observation schemes?","title":"... ergonomically deal with simple observation schemes?","text":"","category":"page"},{"location":"how_to_guides/simple_os/#","page":"... ergonomically deal with simple observation schemes?","title":"... ergonomically deal with simple observation schemes?","text":"Often times the data are collected according to a single, or maybe only two different observational regimes. For instance, we might be recording a single coordinate of a process with low precision but high frequency and additionally make low frequency but high precision observation of all coordinates. In these types of scenarios the most convenient way of preparing the data is to use ObsScheme struct that you can read more about here.","category":"page"},{"location":"how_to_guides/simple_os/#","page":"... ergonomically deal with simple observation schemes?","title":"... ergonomically deal with simple observation schemes?","text":"Simply define a list of all observation regimes that you will be using:","category":"page"},{"location":"how_to_guides/simple_os/#","page":"... ergonomically deal with simple observation schemes?","title":"... ergonomically deal with simple observation schemes?","text":"using ObservationSchemes, StaticArrays\nall_obs_types = [\n    LinearGsnObs(\n        0.0, (@SVector [0.0]);\n        L = (@SMatrix [0.0 1.0 0.0;]), # observe only the second coordinate,\n        Σ = (@SMatrix [1.0;]), # low precision\n    ),\n    LinearGsnObs(\n        0.0, (@SVector [0.0, 0.0, 0.0]);\n        L = SDiagonal(1.0, 1.0, 1.0), # observe all coordinates,\n        Σ = 1e-5*SDiagonal(1.0, 1.0, 1.0), # high precision\n    ),\n]","category":"page"},{"location":"how_to_guides/simple_os/#","page":"... ergonomically deal with simple observation schemes?","title":"... ergonomically deal with simple observation schemes?","text":"And define a pattern in which the templates from all_obs_types are going to be used to record the observations","category":"page"},{"location":"how_to_guides/simple_os/#","page":"... ergonomically deal with simple observation schemes?","title":"... ergonomically deal with simple observation schemes?","text":"# 5 low precis obs, 1 high precis obs, 5 low precis obs, 1 high precis obs, etc...\nobs_sch = ObsScheme(all_obs_types...; pattern=[1,1,1,1,1,2])","category":"page"},{"location":"how_to_guides/simple_os/#","page":"... ergonomically deal with simple observation schemes?","title":"... ergonomically deal with simple observation schemes?","text":"Then you can take your raw data and decorate it:","category":"page"},{"location":"how_to_guides/simple_os/#","page":"... ergonomically deal with simple observation schemes?","title":"... ergonomically deal with simple observation schemes?","text":"raw_data_tt_and_xx_pairs = ...\n\ndata = load_data(obs_sch, raw_data_tt_and_xx_pairs)","category":"page"},{"location":"how_to_guides/simple_os/#","page":"... ergonomically deal with simple observation schemes?","title":"... ergonomically deal with simple observation schemes?","text":"If you are doing some testing and don't have the raw data yet, just a full, simulated trajectory from the model, you may collect the data directly according to the scheme obs_sch (the data will be perturbed by the noise that you've specified) optionally recording the data in jumps (because the observations might be done once every τ seconds, where τ > dt, dt being the time-step used to simulate the trajectory):","category":"page"},{"location":"how_to_guides/simple_os/#","page":"... ergonomically deal with simple observation schemes?","title":"... ergonomically deal with simple observation schemes?","text":"path = ...\n\ndata = collect(obs_sch, path, 1000 #= record 1 in 1000 pts =#, false #= omit start pt =#)","category":"page"},{"location":"how_to_guides/update_params/#How-to-leverage-AllObservations-to-efficiently-update-parameters?-1","page":"... leverage AllObservations to efficiently update parameters?","title":"How to leverage AllObservations to efficiently update parameters?","text":"","category":"section"},{"location":"how_to_guides/update_params/#","page":"... leverage AllObservations to efficiently update parameters?","title":"... leverage AllObservations to efficiently update parameters?","text":"","category":"page"},{"location":"how_to_guides/update_params/#","page":"... leverage AllObservations to efficiently update parameters?","title":"... leverage AllObservations to efficiently update parameters?","text":"The main strength of AllObservations struct is that it holds information about which parameters appear in which diffusion law or in which observation. In that way, you can work on a single, global vector of parameters and if at any point any of those parameters change, then you may leverage AllObservations to quickly identify all laws and observations that depended on a changed parameter and then update them.","category":"page"},{"location":"how_to_guides/update_params/#","page":"... leverage AllObservations to efficiently update parameters?","title":"... leverage AllObservations to efficiently update parameters?","text":"For instance","category":"page"},{"location":"how_to_guides/update_params/#","page":"... leverage AllObservations to efficiently update parameters?","title":"... leverage AllObservations to efficiently update parameters?","text":"using ObservationSchemes\nconst OBS = ObservationSchemes\nmutable struct LawA α; β; end\nOBS.var_parameter_names(P::LawA) = (:α, :β)\nmutable struct LawB γ; β; end\nOBS.var_parameter_names(P::LawB) = (:γ, :β)\n\nrecordings = [\n    (\n        P = LawA(10,20),\n        obs = [\n            LinearGsnObs(1.0, 1.0; Σ=1.0),\n            LinearGsnObs(2.0, 2.0; full_obs=true),\n            LinearGsnObs(3.0, 3.0; Σ=2.0),\n        ],\n        t0 = 0.0,\n        x0_prior = KnownStartingPt(2.0),\n    ), # recording n°1\n    (\n        P = LawA(10,20),\n        obs = [\n            LinearGsnObs(1.3, 1.0; full_obs=true),\n            LinearGsnObs(2.3, 2.0; full_obs=true),\n            LinearGsnObs(3.3, 3.0; full_obs=true),\n        ],\n        t0 = 0.3,\n        x0_prior = KnownStartingPt(-2.0),\n    ), # recording n°2\n    (\n        P = LawB(30,40),\n        obs = [\n            LinearGsnObs(1.5, 1.0; Σ=1.0),\n            LinearGsnObs(2.5, 2.0; Σ=1.0),\n        ],\n        t0 = 0.5,\n        x0_prior = KnownStartingPt(10.0),\n    ), # recording n°3\n]\n\nall_obs = AllObservations()\nadd_recordings!(all_obs, recordings)\n\nadd_dependency!(\n    all_obs,\n    Dict(\n        :α_shared => [(1, :α), (2, :α)],\n        :β_shared => [(1, :β), (2, :β), (3,:β)],\n    )\n)\n\nao, _ = initialize(all_obs)","category":"page"},{"location":"how_to_guides/update_params/#","page":"... leverage AllObservations to efficiently update parameters?","title":"... leverage AllObservations to efficiently update parameters?","text":"julia> print_parameters(ao)\n\nThere are 6 independent recordings.\nThere are also 3 variable parameters.\n* * *\nYou may define the var-parameters using the following template:\n# start of template\nusing OrderedCollections\n\nθ_init = OrderedDict(\n    :β_shared => ... , # param 1\n    :α_shared => ... , # param 2\n    :REC3_γ => ... , # param 3\n)\n# end of template\nand in an MCMC setting you may let your parameter update step\nrefer to a subset of indices you wish to update using the order\ngiven above.\n* * *","category":"page"},{"location":"how_to_guides/update_params/#","page":"... leverage AllObservations to efficiently update parameters?","title":"... leverage AllObservations to efficiently update parameters?","text":"We have","category":"page"},{"location":"how_to_guides/update_params/#","page":"... leverage AllObservations to efficiently update parameters?","title":"... leverage AllObservations to efficiently update parameters?","text":"julia> for rec in ao.recordings\n           println(rec.P)\n       end\nLawA(10, 20)\nLawA(10, 20)\nLawA(10, 20)\nLawA(10, 20)\nLawA(10, 20)\nLawB(30, 40)","category":"page"},{"location":"how_to_guides/update_params/#","page":"... leverage AllObservations to efficiently update parameters?","title":"... leverage AllObservations to efficiently update parameters?","text":"Suppose that :α_shared (corresponding to all instances of :α in probability laws) changed to 100.0. To make this change write:","category":"page"},{"location":"how_to_guides/update_params/#","page":"... leverage AllObservations to efficiently update parameters?","title":"... leverage AllObservations to efficiently update parameters?","text":"global_pname = :α_shared\nnew_val = 100\n\n(\n    p->setfield!(\n        ao.recordings[p[1]].P,\n        p[2],\n        new_val\n    )\n).(\n    ao.param_depend[global_pname]\n)","category":"page"},{"location":"how_to_guides/update_params/#","page":"... leverage AllObservations to efficiently update parameters?","title":"... leverage AllObservations to efficiently update parameters?","text":"Inspecting the laws now:","category":"page"},{"location":"how_to_guides/update_params/#","page":"... leverage AllObservations to efficiently update parameters?","title":"... leverage AllObservations to efficiently update parameters?","text":"julia> for rec in ao.recordings\n           println(rec.P)\n       end\nLawA(100.0, 20)\nLawA(100.0, 20)\nLawA(100.0, 20)\nLawA(100.0, 20)\nLawA(100.0, 20)\nLawB(30, 40)","category":"page"},{"location":"how_to_guides/update_params/#","page":"... leverage AllObservations to efficiently update parameters?","title":"... leverage AllObservations to efficiently update parameters?","text":"In here we've modified the local fields of the AllObservations containing the target laws. However, in practice, these fields are usually considered to be dummies and instead we have a different array of laws corresponding to recordings on which we want to change the parameters. For instance:","category":"page"},{"location":"how_to_guides/update_params/#","page":"... leverage AllObservations to efficiently update parameters?","title":"... leverage AllObservations to efficiently update parameters?","text":"PP = [deepcopy(rec.P) for rec in ao.recordings]","category":"page"},{"location":"how_to_guides/update_params/#","page":"... leverage AllObservations to efficiently update parameters?","title":"... leverage AllObservations to efficiently update parameters?","text":"Then, we we update parameters, we usually want to update PP, not ao.recordings[i].Ps. This is of course easily done analogously to how it was done above:","category":"page"},{"location":"how_to_guides/update_params/#","page":"... leverage AllObservations to efficiently update parameters?","title":"... leverage AllObservations to efficiently update parameters?","text":"(\n    p->setfield!(\n        PP[p[1]],\n        p[2],\n        new_val\n    )\n).(\n    ao.param_depend[global_pname]\n)","category":"page"},{"location":"how_to_guides/csv_files/#How-to-read-data-directly-from-a-.csv-file?-1","page":"... read data directly from a .csv file?","title":"How to read data directly from a .csv file?","text":"","category":"section"},{"location":"how_to_guides/csv_files/#","page":"... read data directly from a .csv file?","title":"... read data directly from a .csv file?","text":"","category":"page"},{"location":"how_to_guides/csv_files/#","page":"... read data directly from a .csv file?","title":"... read data directly from a .csv file?","text":"If your data are saved in a .csv file such that each row i contains time-of-obs_i, obs_i-coord_1, obs_i-coord_2, obs_i-coord_3, ..., then you can load the data in using function load_data and passing a path to your file, as in:","category":"page"},{"location":"how_to_guides/csv_files/#","page":"... read data directly from a .csv file?","title":"... read data directly from a .csv file?","text":"obs_scheme = ...\ndata = load_data(obs_scheme, \"path/to/your/file/filename.csv\")","category":"page"},{"location":"manual/multiple_observations/#Multiple-observations-1","page":"Multiple observations","title":"Multiple observations","text":"","category":"section"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"In practice, we gather multiple observations of a single trajectory of a stochastic process. In this package, we refer to multiple discrete-time observations of a single trajectory as a single recording. We do not enforce any structure on a single recording and instead use a convention of using an appropriate NamedTuple. However, when combining multiple recordings into a single data object AllObservations it is expected that each recording follows the said convention.","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"Below we describe how to handle observations of","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"a single recording\nmultiple recordings from the same law\nmultiple recordings from multiple laws","category":"page"},{"location":"manual/multiple_observations/#Defining-a-single-recording-1","page":"Multiple observations","title":"Defining a single recording","text":"","category":"section"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"To fully describe a single recording we need four elements:","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"The law of the underlying stochastic process\nA starting time\nA prior over the starting point\nDiscrete-time observations of the process","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"Consequently, this package adopts the convention of defining a single recording with a NamedTuple:","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"recording = (\n    P = ...,\n    obs = ...,\n    t0 = ...,\n    x0_prior = ...,\n)","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"The law P needs to be defined by the user.","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"tip: Tip\nTo define diffusion laws you may use DiffusionDefinition.jl. To define conditioned diffusion laws you may use GuidedProposals.jl.","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"warning: Warning\nThere must exist an implementation of a function var_parameter_names(::typeof(P)) if one wants to use functions and structs presented below.","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"obs is assumed to be a vector of observations, with each element being of the type inheriting from Observation{D,T}. x0_prior is assumed to inherit from StartingPtPrior{T}. We provide helper functions that create a NamedTuple in the format above:","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"ObservationSchemes.build_recording","category":"page"},{"location":"manual/multiple_observations/#ObservationSchemes.build_recording","page":"Multiple observations","title":"ObservationSchemes.build_recording","text":"build_recording(P, obs, t0, x0_prior)\n\nA utility function that creates an appropriate NamedTuple that represents a single recording.\n\n\n\n\n\nbuild_recording(\n    ::Type{K}, tt, observs::Vector, P, t0, x0_prior; kwargs...\n) where K\n\nA utility function for building a recording. Times of recordings are assumed to be stored in tt and their values in observs. K is the type of observation (for instance LinearGsnObs). kwargs are name arguments that are passed to every single initializer of K.\n\n\n\n\n\n","category":"function"},{"location":"manual/multiple_observations/#Defining-multiple-recordings-1","page":"Multiple observations","title":"Defining multiple recordings","text":"","category":"section"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"A struct AllObservations allows for a systematic definition of multiple recordings and, in addition, provides some handy functionality.","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"ObservationSchemes.AllObservations","category":"page"},{"location":"manual/multiple_observations/#ObservationSchemes.AllObservations","page":"Multiple observations","title":"ObservationSchemes.AllObservations","text":"struct AllObservations\n    recordings::Vector{Any}\n    param_depend::Dict{Symbol,Vector{Pair{Int64, Symbol}}}\n    obs_depend::Dict{Symbol,Vector{Tuple{Int64,Int64,Int64}}}\n    param_depend_rev::Vector{Vector{Tuple{Symbol,Symbol}}}\n    obs_depend_rev::Vector{Vector{Vector{Tuple{Symbol,Int64}}}}\nend\n\nA struct gathering multiple observations of diffusion processes. Additionaly, the interdependence structure between parameters shared between various diffusions laws used to generate the recorded data is kept.\n\nrecordings: collects all recordings\nparam_depend: is a dictionary with\nkeys: parameter labels\nvalues: vectors that collect all indices of recordings whose laws depend         on a corresponding parameter (in fact collects Pairs:         idx-of-a-recording => name-of-parameter).\nobs_depend: does the same as param_depend but for observations.               In this case values are vectors that collect Tuples in a               format:               (idx-of-a-recording, idx-of-an-observation,               idx-of-parameter-in-θ-vector).\nparam_depend_rev: gives for each recording a list of variable parameters                     that its law depends on. These are given in a format                     global-param-name => local-param-name.\n\nnote: Note\nWe use the term variable to refer to those parameters that are returned after a call var_parameter_names(typeof(P)).\n\nobs_depend_rev: does the same as param_depend_rev but for the                   observations. These are given in a format                   global-param-name => local-param-idx.\n\n\n\nAllObservations(;P=nothing, obs=nothing, t0=nothing, x0_prior=nothing)\n\nDefault constructor creating either an empty AllObservations object, or initiating it immediately with a single recording where the target comes from the law P, the observations are stored in obs and the observed process was started at time t0 from som position which we put a prior x0_prior on.\n\nAllObservations(recording::NamedTuple)\n\nConstructor creating an AllObservations object and initiating it immediately with a single recording where the target comes from the law recording.P, the observations are stored in recording.obs and the starting point is at time recording.t0 and has a prior x0_prior.\n\n\n\n\n\n","category":"type"},{"location":"manual/multiple_observations/#Recordings-that-share-a-single-law-1","page":"Multiple observations","title":"Recordings that share a single law","text":"","category":"section"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"We can define multiple recordings using functions","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"ObservationSchemes.add_recording!\nObservationSchemes.add_recordings!","category":"page"},{"location":"manual/multiple_observations/#ObservationSchemes.add_recording!","page":"Multiple observations","title":"ObservationSchemes.add_recording!","text":"add_recording!(all_obs::AllObservations, recording::NamedTuple)\n\nAdd a new recording recording to an observations container all_obs.\n\n\n\n\n\n","category":"function"},{"location":"manual/multiple_observations/#ObservationSchemes.add_recordings!","page":"Multiple observations","title":"ObservationSchemes.add_recordings!","text":"add_recordings!(\n    all_obs::AllObservations,\n    recordings::AbstractArray{<:NamedTuple}\n)\n\nAdd multiple new recordings recordings to an observations container all_obs.\n\n\n\n\n\n","category":"function"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"for instance:","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"const OBS = ObservationSchemes\nstruct LawA α; β; end\nOBS.var_parameter_names(P::LawA) = (:α, :β)\n\nrecordings = [\n    (\n        P = LawA(10,20),\n        obs = [\n            LinearGsnObs(1.0, 1.0; Σ=1.0),\n            LinearGsnObs(2.0, 2.0; full_obs=true),\n            LinearGsnObs(3.0, 3.0; Σ=2.0),\n        ],\n        t0 = 0.0,\n        x0_prior = KnownStartingPt(2.0),\n    ), # recording n°1\n    (\n        P = LawA(10,20),\n        obs = [\n            LinearGsnObs(1.3, 1.0; full_obs=true),\n            LinearGsnObs(2.3, 2.0; full_obs=true),\n            LinearGsnObs(3.3, 3.0; full_obs=true),\n        ],\n        t0 = 0.3,\n        x0_prior = KnownStartingPt(-2.0),\n    ), # recording n°2\n]\n\nall_obs = AllObservations()\nadd_recordings!(all_obs, recordings)","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"note: Note\nIn here we defined the vector recordings verbatim, however we provide an ObsScheme struct together with @load_data macro to do this in an automatic and concise way for many observations at once (see the following section to learn more about this).","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"Observations can be accessed via all_obs.recordings. By default the laws from different recordings are assumed to be independent, but we can tell AllObservations object that they are the same by indicating that the laws share some subsets (possibly all) parameters. This can be done by passing an appropriate dictionary to a function:","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"ObservationSchemes.add_dependency!","category":"page"},{"location":"manual/multiple_observations/#ObservationSchemes.add_dependency!","page":"Multiple observations","title":"ObservationSchemes.add_dependency!","text":"add_dependency!(all_obs::AllObservations, dep::Dict)\n\nAdd a dependency structure dep between parameters shared across various laws and observations used to generate various recordings stored in an observations container all_obs.\n\n\n\n\n\n","category":"function"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"add_dependency!(\n    all_obs,\n    Dict(\n        :α_shared => [(1, :α), (2, :α)],\n        :β_shared => [(1, :β), (2, :β)],\n    )\n)","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"The first (respectively second) entry in the dictionary tells all_obs that there is a parameter, which from now on will be labeled :α_shared (resp. :β_shared), that is present in the law of recording 1 and the law of recording 2 and in both of these cases if one calls var_parameter_names(P) then the referred to parameter should have a name :α (resp. :β).","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"note: Note\nIf the parameter appears in the observation instead of the law, then the previous tuple of the format (rec_idx, :param-name) must be substituted with: (rec_idx, obs_idx, param_idx_in_obs_vec), for instance:add_dependency!(\n    all_obs,\n    Dict(\n        :γ_shared => [(1, 2, 3), (40, 400, 4)],\n    )\n)indicates that there is a shared parameter :γ_shared that enters:the second observations in a first recording and that it is the third parameter of this observation\nthe 400th observation of the 40th recording and that it enters the 4th parameter of that observation","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"Now, we can additionally call","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"ObservationSchemes.initialize","category":"page"},{"location":"manual/multiple_observations/#ObservationSchemes.initialize","page":"Multiple observations","title":"ObservationSchemes.initialize","text":"initialize(all_obs::AllObservations)\n\nSplit the recordings at the times of full observations to make full use of the Markov property (and make the code readily parallelisable). Introduce all variable parameters that were not mentioned in the current dependency dictionary. Create internal dictionaries all_obs.param_depend_rev and all_obs.obs_depend_rev.\n\n\n\n\n\n","category":"function"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"as in:","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"initialised_all_obs, old_to_new_idx = initialize(all_obs)","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"to perform three useful operations.","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"First, all parameters that are not shared between various laws will be marked (here, there is no such parameter, so this step does not do anything, see the example below which illustrates this idea),\nSecond, the recordings are split at the times at which full observations are made, as full observations allows for employment of the Markov property and treatment of the problem in parallel. As a result, initialised_all_obs now has 5 recordings, all coming from the same law LawA.\nThird, an additional dependence structure is introduced that allows for efficient retrieval of information about parameter dependence when iterating through laws and observations.","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"tip: Tip\nThe old_to_new_idx might be helpful for keeping track of the original indices of recordings.","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"Some useful information is printed when we call","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"ObservationSchemes.print_parameters","category":"page"},{"location":"manual/multiple_observations/#ObservationSchemes.print_parameters","page":"Multiple observations","title":"ObservationSchemes.print_parameters","text":"print_parameters(all_obs::AllObservations)\n\nPrint information about the variable parameters about which the all_obs.param_depend object stores some interdependency information.\n\n\n\n\n\n","category":"function"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"julia> print_parameters(initialised_all_obs)\n\nThere are 5 independent recordings.\nThere are also 2 variable parameters.\n* * *\nYou may define the var-parameters using the following template:\n# start of template\nusing OrderedCollections\n\nθ_init = OrderedDict(\n    :β_shared => ... , # param 1\n    :α_shared => ... , # param 2\n)\n# end of template\nand in an MCMC setting you may let your parameter update step\nrefer to a subset of indices you wish to update using the order\ngiven above.\n* * *","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"We can also inspect the field param_depend_rev:","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"julia> initialised_all_obs.param_depend_rev\n5-element Array{Array{Tuple{Symbol,Symbol},1},1}:\n [(:β_shared, :β), (:α_shared, :α)]\n [(:β_shared, :β), (:α_shared, :α)]\n [(:β_shared, :β), (:α_shared, :α)]\n [(:β_shared, :β), (:α_shared, :α)]\n [(:β_shared, :β), (:α_shared, :α)]","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"which allows for iterating through recordings and seeing immediately which parameters they depend on, in particular:","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"how these parameters are referred to by the all_obs struct\nhow these parameters are referred to by the individual laws","category":"page"},{"location":"manual/multiple_observations/#Recordings-under-multiple-laws-1","page":"Multiple observations","title":"Recordings under multiple laws","text":"","category":"section"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"It should be clear that the formalism above allows for definition of recordings coming from multiple diffusion laws. For instance, we can have","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"struct LawB γ; β; end\nOBS.var_parameter_names(P::LawB) = (:γ, :β)\n\nextra_recording = (\n    P = LawB(30,40),\n    obs = [\n        LinearGsnObs(1.5, 1.0; Σ=1.0),\n        LinearGsnObs(2.5, 2.0; Σ=1.0),\n    ],\n    t0 = 0.5,\n    x0_prior = KnownStartingPt(10.0),\n) # recording n°3\npush!(recordings, extra_recording)\n\nall_obs = AllObservations()\nadd_recordings!(all_obs, recordings)","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"The dictionary specifying interdependence between the laws of stochastic processes can now be defined as follows:","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"add_dependency!(\n    all_obs,\n    Dict(\n        :α_shared => [(1, :α), (2, :α)],\n        :β_shared => [(1, :β), (2, :β), (3,:β)],\n    )\n)","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"where, notice presence of additional (3,:β). This time, calling","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"initialised_all_obs, _ = initialize(all_obs)","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"not only splits the recordings at the time of full observations (resulting in 6 independent recordings), but also introduces a new named parameter REC3_γ that only the last recording depends on. This comes from the fact that in the original all_obs the third recording came from law LawB, which depends on the parameter γ that was not shared with any other recording and hence did not appear in the inter-dependency dictionary. Every such \"lonely\" parameter is introduced by a function initialize and is given a name by pre-pending its original name with REC($i)_, with ($i) denoting the original index of a recording that the parameter came from.","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"Now:","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"julia> print_parameters(initialised_all_obs)\n\nThere are 6 independent recordings.\nThere are also 3 variable parameters.\n* * *\nYou may define the var-parameters using the following template:\n# start of template\nusing OrderedCollections\n\nθ_init = OrderedDict(\n    :β_shared => ... , # param 1\n    :α_shared => ... , # param 2\n    :REC3_γ => ... , # param 3\n)\n# end of template\nand in an MCMC setting you may let your parameter update step\nrefer to a subset of indices you wish to update using the order\ngiven above.\n* * *","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"and","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"julia> initialised_all_obs.param_depend_rev\n6-element Array{Array{Tuple{Symbol,Symbol},1},1}:\n [(:β_shared, :β), (:α_shared, :α)]\n [(:β_shared, :β), (:α_shared, :α)]\n [(:β_shared, :β), (:α_shared, :α)]\n [(:β_shared, :β), (:α_shared, :α)]\n [(:β_shared, :β), (:α_shared, :α)]\n [(:β_shared, :β), (:REC3_γ, :γ)]","category":"page"},{"location":"how_to_guides/custom_priors/#how_to_custom_prior-1","page":"... define custom priors over starting points?","title":"How to define custom priors over starting points?","text":"","category":"section"},{"location":"how_to_guides/custom_priors/#","page":"... define custom priors over starting points?","title":"... define custom priors over starting points?","text":"","category":"page"},{"location":"how_to_guides/custom_priors/#","page":"... define custom priors over starting points?","title":"... define custom priors over starting points?","text":"To define custom priors over starting points you should define a struct with a prior and then override the behavior of rand and logpdf for it.","category":"page"},{"location":"how_to_guides/custom_priors/#","page":"... define custom priors over starting points?","title":"... define custom priors over starting points?","text":"For instance to define a prior that can use any distribution from Distributions.jl you can write:","category":"page"},{"location":"how_to_guides/custom_priors/#","page":"... define custom priors over starting points?","title":"... define custom priors over starting points?","text":"using Distributions\n\nstruct CustomPrior{T,S} <: StartingPtPrior{T}\n    dist::S\n    CustomPrior(dist::S) where S = new{typeof(rand(dist)),S}(dist)\nend\n\n# simulate a starting point\nBase.rand(p::CustomPrior) = rand(p.dist)\n\n# evaluate log density\nDistributions.logpdf(p::CustomPrior, y) = logpdf(p.dist, y)","category":"page"},{"location":"how_to_guides/custom_priors/#","page":"... define custom priors over starting points?","title":"... define custom priors over starting points?","text":"This is a minimal example that allows you to sample from the prior and evaluate the log-density. However, it does not allow you to employ the Crank–Nicolson scheme that turns out to be necessary for some MCMC applications. Implementing the Crank–Nicolson scheme for general distributions might not be possible and in this package we have it implemented only for the multivariate Gaussian laws.","category":"page"},{"location":"manual/start_pt_prior/#Priors-over-starting-points-1","page":"Priors over starting points","title":"Priors over starting points","text":"","category":"section"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"On top of decorating each observation with appropriate information, for stochastic processes we need to provide additional information that describes the starting position of the process (as, for instance, no observation may be made at the initial time). This is done through prior distributions.","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"All priors over starting points inherit from","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"ObservationSchemes.StartingPtPrior","category":"page"},{"location":"manual/start_pt_prior/#ObservationSchemes.StartingPtPrior","page":"Priors over starting points","title":"ObservationSchemes.StartingPtPrior","text":"StartingPtPrior{T}\n\nTypes inheriting from the abstract type StartingPtPrior indicate the prior that is put on the starting point of the observed path of some stochastic process. T denotes the DataType of the starting point.\n\n\n\n\n\n","category":"type"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"They all must implement the following methods","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"Base.rand(G::ObservationSchemes.StartingPtPrior, [z, ρ=0.0])\nObservationSchemes.start_pt(z, G::ObservationSchemes.StartingPtPrior, P)\nObservationSchemes.start_pt(z, G::ObservationSchemes.StartingPtPrior)\nObservationSchemes.logpdf(G::ObservationSchemes.StartingPtPrior, y)","category":"page"},{"location":"manual/start_pt_prior/#Base.rand-Tuple{ObservationSchemes.StartingPtPrior,Any}","page":"Priors over starting points","title":"Base.rand","text":"Base.rand(G::StartingPtPrior, [z, ρ=0.0])\n\nSample a new starting point according to its prior distribution. An implementation with arguments z, ρ implements a preconditioned Crank-Nicolson scheme with memory parameter ρ and a current non-centered variable z. z is also referred to as the driving noise.\n\n\n\n\n\n","category":"method"},{"location":"manual/start_pt_prior/#ObservationSchemes.start_pt-Tuple{Any,ObservationSchemes.StartingPtPrior,Any}","page":"Priors over starting points","title":"ObservationSchemes.start_pt","text":"start_pt(z, G::StartingPtPrior, P)\n\nCompute a new starting point from the white noise for a given posterior distribution obtained from combining prior G and the likelihood encoded by the object P.\n\n\n\n\n\n","category":"method"},{"location":"manual/start_pt_prior/#ObservationSchemes.start_pt-Tuple{Any,ObservationSchemes.StartingPtPrior}","page":"Priors over starting points","title":"ObservationSchemes.start_pt","text":"start_pt(z, G::StartingPtPrior)\n\nCompute a new starting point from the white noise for a given prior distribution G\n\n\n\n\n\n","category":"method"},{"location":"manual/start_pt_prior/#Distributions.logpdf-Tuple{ObservationSchemes.StartingPtPrior,Any}","page":"Priors over starting points","title":"Distributions.logpdf","text":"logpdf(G::StartingPtPrior, y)\n\nlog-probability density function evaluated at y of a prior distribution G\n\n\n\n\n\n","category":"method"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"and should also implement","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"ObservationSchemes.inv_start_pt(y, G::ObservationSchemes.StartingPtPrior, P)","category":"page"},{"location":"manual/start_pt_prior/#ObservationSchemes.inv_start_pt-Tuple{Any,ObservationSchemes.StartingPtPrior,Any}","page":"Priors over starting points","title":"ObservationSchemes.inv_start_pt","text":"inv_start_pt(y, G::StartingPtPrior, P)\n\nCompute the driving noise that is needed to obtain starting point y under prior G and the likelihood in P\n\n\n\n\n\n","category":"method"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"for MCMC setting. In this package we provide implementations for the following types of starting points","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"Known, fixed starting points\nGaussian priors over starting points","category":"page"},{"location":"manual/start_pt_prior/#Known-starting-point-1","page":"Priors over starting points","title":"Known starting point","text":"","category":"section"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"This is the simplest setting in which the starting point is assumed to be known.","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"ObservationSchemes.KnownStartingPt","category":"page"},{"location":"manual/start_pt_prior/#ObservationSchemes.KnownStartingPt","page":"Priors over starting points","title":"ObservationSchemes.KnownStartingPt","text":"struct KnownStartingPt{T} <: StartingPtPrior{T}\n    y::T\nend\n\nIndicates that the starting point is known and stores its value in y\n\nKnownStartingPt(y::T) where T\n\nBase constructor.\n\n\n\n\n\n","category":"type"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"It can be defined with","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"x0 = [1.0, 2.0]\nx0_prior = KnownStartingPt(x0)","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"a call to rand or start_pt will simply return the fixed starting point and logpdf(x0_prior, y) evaluates to 0 so long as x0 == y.","category":"page"},{"location":"manual/start_pt_prior/#Gaussian-priors-1","page":"Priors over starting points","title":"Gaussian priors","text":"","category":"section"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"A Gaussian prior over the starting point.","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"ObservationSchemes.GsnStartingPt","category":"page"},{"location":"manual/start_pt_prior/#ObservationSchemes.GsnStartingPt","page":"Priors over starting points","title":"ObservationSchemes.GsnStartingPt","text":"struct GsnStartingPt{T,S,TM} <: StartingPtPrior{T} where {S}\n    μ::T\n    Σ::S\n    Λ::S\n    μ₀::T\n    Σ₀::UniformScaling\nend\n\nIndicates that the starting point is equipped with a Gaussian prior with mean μ and covariance matrix Σ (and pre-computed precision Λ:=Σ⁻¹). Sampling is always done via non-centred parametrization, by sampling white noise z according to Gaussian with zero mean and identity covariance: μ₀ and Σ₀, and then transforming z to a variable with mean and covariance μ and Σ.\n\nGsnStartingPt(μ::T, Σ::S)\n\nBase constructor. It initialises the mean μ and covariance Σ parameters and Λ is set according to Λ:=Σ⁻¹.\n\n\n\n\n\n","category":"type"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"Can be defined with","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"μ, Σ = [1.0, 2.0], [1.0 0.0; 0.0 1.0]\nx0_prior = GsnStartingPt(μ, Σ)","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"to set the mean and covariance to μ and Σ respectively. The underlying idea behind Gaussian starting point priors is that of non-centred parametrisation, so that a possibility of local updates is granted. More precisely any sampling is done with z∼N(0,Id) variables, which are then transformed to N(μ,Σ) via linear transformations. In particular, sampling with rand can be done with local perturbations via Crank-Nicolson scheme.","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"ObservationSchemes.rand","category":"page"},{"location":"manual/start_pt_prior/#Base.rand","page":"Priors over starting points","title":"Base.rand","text":"Base.rand(G::StartingPtPrior, [z, ρ=0.0])\n\nSample a new starting point according to its prior distribution. An implementation with arguments z, ρ implements a preconditioned Crank-Nicolson scheme with memory parameter ρ and a current non-centered variable z. z is also referred to as the driving noise.\n\n\n\n\n\nrand([rng::Random.AbstractRNG], G::GsnStartingPt, z, ρ=0.0)\n\nSample new white noise using Crank-Nicolson scheme with memory parameter ρ and a previous value of the white noise stored inside object G\n\n\n\n\n\nrand([rng::Random.AbstractRNG], G::GsnStartingPt)\n\nSample new starting point according to its prior distribution.\n\n\n\n\n\nrand([rng::Random.AbstractRNG], G::KnownStartingPt, args...)\n\nStarting point is known. Nothing can be sampled. Returning known starting point.\n\n\n\n\n\nBase.rand([rng::Random.AbstractRNG], o::LinearGsnObs, X)\n\nSample an observation according to\n\nV  L X + ξquad mboxwhere  ξN(μΣ)\n\nwith L, μ and Σ defined in o.\n\n\n\n\n\n","category":"function"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"inv_start_pt returns the non-centrally parametrised noise z that produces a given starting point x0:","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"ObservationSchemes.inv_start_pt","category":"page"},{"location":"manual/start_pt_prior/#ObservationSchemes.inv_start_pt","page":"Priors over starting points","title":"ObservationSchemes.inv_start_pt","text":"inv_start_pt(y, G::StartingPtPrior, P)\n\nCompute the driving noise that is needed to obtain starting point y under prior G and the likelihood in P\n\n\n\n\n\ninv_start_pt(y, G::GsnStartingPt, P)\n\nCompute the driving noise that is needed to obtain starting point y under prior G and the likelihood in P\n\n\n\n\n\ninv_start_pt(y, G::KnownStartingPt, P)\n\nStarting point known, no need for dealing with white noise, use convention of returning y\n\n\n\n\n\n","category":"function"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"and start_pt is the reverse operation","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"ObservationSchemes.start_pt","category":"page"},{"location":"manual/start_pt_prior/#ObservationSchemes.start_pt","page":"Priors over starting points","title":"ObservationSchemes.start_pt","text":"start_pt(z, G::StartingPtPrior, P)\n\nCompute a new starting point from the white noise for a given posterior distribution obtained from combining prior G and the likelihood encoded by the object P.\n\n\n\n\n\nstart_pt(z, G::StartingPtPrior)\n\nCompute a new starting point from the white noise for a given prior distribution G\n\n\n\n\n\nstart_pt(z, G::GsnStartingPt, P)\n\nCompute a new starting point from the white noise for a given posterior distribution obtained from combining prior G and the likelihood encoded by the object P.\n\n\n\n\n\nstart_pt(z, G::GsnStartingPt)\n\nCompute a new starting point from the white noise for a given prior distribution G\n\n\n\n\n\nstart_pt(z, G::KnownStartingPt, P)\n\nReturn starting point\n\n\n\n\n\nstart_pt(G::KnownStartingPt, P)\n\nReturn starting point\n\n\n\n\n\n","category":"function"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"tip: Tip\nTo see how to define your own priors over starting points see a How-to-guide on Defining custom priors over starting points","category":"page"},{"location":"manual/utility_functions/#Utility-functions-1","page":"Utility fuctions","title":"Utility functions","text":"","category":"section"},{"location":"manual/utility_functions/#","page":"Utility fuctions","title":"Utility fuctions","text":"We provide some additional utility functions.","category":"page"},{"location":"manual/utility_functions/#","page":"Utility fuctions","title":"Utility fuctions","text":"Modules = [ObservationSchemes]\nPages   = [\"convenience_functions.jl\"]","category":"page"},{"location":"manual/utility_functions/#ObservationSchemes.num_obs-Tuple{AllObservations}","page":"Utility fuctions","title":"ObservationSchemes.num_obs","text":"num_obs(all_obs::AllObservations)\n\nReturn the total number of observations in all recordings of all_obs.\n\n\n\n\n\n","category":"method"},{"location":"manual/utility_functions/#ObservationSchemes.num_recordings-Tuple{AllObservations}","page":"Utility fuctions","title":"ObservationSchemes.num_recordings","text":"num_recordings(all_obs::AllObservations)\n\nReturn the total number of recordings in all_obs.\n\n\n\n\n\n","category":"method"},{"location":"manual/utility_functions/#ObservationSchemes.package","page":"Utility fuctions","title":"ObservationSchemes.package","text":"package(objs::AbstractArray, all_obs::AllObservations)\n\npackage(objs::AbstractArray, recording::NamedTuple)\n\npackage(obj, recording::NamedTuple)\n\npackage(objs::AbstractArray, old_to_new_idx::Dict, all_obs::AllObservations)\n\npackage(obj, all_obs::AllObservations)\n\nVarious packaging functions that zip together objects/functions/structs together with observations defined in AllObservations/recording\n\n\n\n\n\n","category":"function"},{"location":"manual/utility_functions/#ObservationSchemes.setup_time_grids","page":"Utility fuctions","title":"ObservationSchemes.setup_time_grids","text":"setup_time_grids(\n    all_obs::AllObservations,\n    dt=0.01,\n    τ=identity,\n    eltype=Float64,\n    already_arranged_tt=nothing\n)\n\nSame as a version for a single recording, but applies recursively  to all recordings in all_obs.\n\n\n\n\n\n","category":"function"},{"location":"manual/utility_functions/#ObservationSchemes.setup_time_grids","page":"Utility fuctions","title":"ObservationSchemes.setup_time_grids","text":"setup_time_grids(\n    recording::NamedTuple,\n    dt=0.01,\n    τ=identity,\n    eltype=Float64,\n    already_arranged_tt=nothing\n)\n\nSame as a version for a single interval, but applies recursively to all inter-observation intervals in recording.\n\n\n\n\n\n","category":"function"},{"location":"manual/utility_functions/#ObservationSchemes.setup_time_grids","page":"Utility fuctions","title":"ObservationSchemes.setup_time_grids","text":"setup_time_grids(\n    t0::Number,\n    T::Number,\n    dt=0.01,\n    τ=identity,\n    eltype=Float64,\n    already_arranged_tt=nothing\n)\n\nSet up a time grid for a single inter-observation interval [t0, T]. Starts with an equidistant time grid with mesh witdh dt and applies a transformation τ afterwards. Alternatively, if already_arranged_tt is passed then the initial setting up of an equidistant grid is omitted and already_arrange_tt is used in its place for the τ transformation.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/single_path/#tutorial_single_path-1","page":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","title":"Defining an observation scheme for a single trajectory from the FitzHugh–Nagumo model","text":"","category":"section"},{"location":"tutorials/single_path/#","page":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","title":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","text":"","category":"page"},{"location":"tutorials/single_path/#","page":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","title":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","text":"In this tutorial we simulate data from the FitzHugh–Nagumo model and then show how to decorate it with information provided by ObservationSchemes.jl.","category":"page"},{"location":"tutorials/single_path/#Generating-complete-data-1","page":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","title":"Generating complete data","text":"","category":"section"},{"location":"tutorials/single_path/#","page":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","title":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","text":"","category":"page"},{"location":"tutorials/single_path/#","page":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","title":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","text":"For this tutorial we will generate some data from the hypoelliptic, stochastic FitzHugh–Nagumo model that you can read more about here. To this end, we will use the functionality from the package DiffusionDefinition.jl.","category":"page"},{"location":"tutorials/single_path/#","page":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","title":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","text":"using DiffusionDefinition, StaticArrays\n@load_diffusion FitzHughNagumo\n\nP = FitzHughNagumo(0.1, -0.8, 1.5, 0.0, 0.3)\ntt = 0.0:0.0001:10.0\nx0 = @SVector [-0.9, -0.9]\nX = rand(P, tt, x0)","category":"page"},{"location":"tutorials/single_path/#","page":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","title":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","text":"X above contains very high frequency observations (conceptually: a continuous recording) of both coordinates of the process without any extrinsic noise. However, when collecting real data one rarely has the luxury of being able to record all coordinates of the process, exactly and without any extrinsic noise. Instead, a very common setup is to record a subset of coordinates perturbed by some noise that is often assumed to be Gaussian. In mathematical notation this becomes:","category":"page"},{"location":"tutorials/single_path/#","page":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","title":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","text":"V_t=LX_t+ξquad ξN(μΣ)quadmboxfor tint_1t_2dots","category":"page"},{"location":"tutorials/single_path/#","page":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","title":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","text":"where L, Σ and μ are matrices and a vector of appropriate dimension. To define this types of observation with ObservationSchemes.jl we can use struct LinearGsnObs. Each observation must be decorated separately and becomes its own instance of LinearGsnObs. Consequently, for each observation we must indicate the time of its collection as well as its value and pass the two to a constructor of LinearGsnObs. We can optionally (and often will have to) specify the matrix L (which by default is assumed to be an identity matrix I), matrix Σ (which by default is assumed to be 1e-11*I) and a vector μ (which by default is assumed to be a zero vector). In principle, we could even change L, μ and Σ from observation to observation, having as many observation schemes as there are observations, but we will (hopefully) rarely have to do that.","category":"page"},{"location":"tutorials/single_path/#Observations-of-a-single-coordinate-1","page":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","title":"Observations of a single coordinate","text":"","category":"section"},{"location":"tutorials/single_path/#","page":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","title":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","text":"","category":"page"},{"location":"tutorials/single_path/#","page":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","title":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","text":"FitzHugh–Nagumo model is used primarily to model the time evolution of the membrane potential. As in practice only the membrane potential itself is recorded (and corresponds to the values taken by the first coordinate) we will use:","category":"page"},{"location":"tutorials/single_path/#","page":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","title":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","text":"L=leftbeginmatrix1 0endmatrixright","category":"page"},{"location":"tutorials/single_path/#","page":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","title":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","text":"We will also assume noisy measurements with Gaussian noise N(001^2) made every 01 seconds. Consequently, each observation has the following format:","category":"page"},{"location":"tutorials/single_path/#","page":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","title":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","text":"using ObservationSchemes\nobs_template = LinearGsnObs(\n    0.0, # dummy time variable\n    (@SVector [0.0]); # dummy observation of a first coordinate\n    L = (@SMatrix [1.0 0.0;]),\n    Σ = (@SMatrix [0.01]),\n)","category":"page"},{"location":"tutorials/single_path/#","page":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","title":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","text":"We could decorate every single observation separately, however, as all of them have the same format we can use a struct ObsScheme to define a template that can be applied to decorating the data efficiently. As there is only one observation type the obs_template is the only object we need to pass to ObsScheme:","category":"page"},{"location":"tutorials/single_path/#","page":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","title":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","text":"obs_scheme = ObsScheme(obs_template)","category":"page"},{"location":"tutorials/single_path/#","page":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","title":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","text":"If there were more than a single type of observation, then we could pass all of them to ObsScheme and then declare the pattern according to which different observations are to be selected. For more information see this page.","category":"page"},{"location":"tutorials/single_path/#","page":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","title":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","text":"As we don't yet have the raw data, only the entire, simulated process we should first reduce it down to raw data (which would be a list of time-points and a list of corresponding observations of the first coordinate) and then we could call load_data to apply obs_scheme to the raw data. However, we can also do all of that in a single step by calling collect to collect the data according to the obs_scheme directly from the simulated data:","category":"page"},{"location":"tutorials/single_path/#","page":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","title":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","text":"data = collect(obs_scheme, X, 1000, true)","category":"page"},{"location":"tutorials/single_path/#","page":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","title":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","text":"The 1000 indicates that only 1 in a 1000 points from X are supposed to be recorded. This corresponds exactly to 1 point every 0.1 seconds. true is a flag for omitting the initial point. We can now plot the simulated trajectory together with our data:","category":"page"},{"location":"tutorials/single_path/#","page":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","title":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","text":"const OBS = ObservationSchemes\nusing Plots\nplot(X, Val(:vs_time), size=(800, 300))\nscatter!(map(x->x.t, data), map(x->OBS.ν(x)[1], data), label=\"data\")","category":"page"},{"location":"tutorials/single_path/#","page":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","title":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","text":"(Image: fhn_single_coord)","category":"page"},{"location":"tutorials/single_path/#Full-code-from-the-tutorial-1","page":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","title":"Full code from the tutorial","text":"","category":"section"},{"location":"tutorials/single_path/#","page":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","title":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","text":"","category":"page"},{"location":"tutorials/single_path/#","page":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","title":"Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model","text":"using DiffusionDefinition, StaticArrays\nusing ObservationSchemes, Plots, Random # Random used only for seeding\nconst OBS = ObservationSchemes\n\n# use this seed for reproducing the tutorial exactly\nRandom.seed!(8)\n\n@load_diffusion FitzHughNagumo\nP = FitzHughNagumo(0.1, -0.8, 1.5, 0.0, 0.3)\ntt = 0.0:0.0001:10.0\nx0 = @SVector [-0.9, -0.9]\nX = rand(P, tt, x0)\n\nobs_template = LinearGsnObs(\n    0.0, # dummy time variable\n    (@SVector [0.0]); # dummy observation of a first coordinate\n    L = (@SMatrix [1.0 0.0;]),\n    Σ = (@SMatrix [0.01]),\n)\nobs_scheme = ObsScheme(obs_template)\ndata = collect(obs_scheme, X, 1000, true)\n\nplot(X, Val(:vs_time), size=(800, 300))\nscatter!(map(x->x.t, data), map(x->OBS.ν(x)[1], data), label=\"data\")","category":"page"},{"location":"manual/observation_schemes/#obs_scheme-1","page":"Observation schemes","title":"Defining observation schemes and loading data","text":"","category":"section"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"","category":"page"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"Decorating each and single one of the observations as in the previous section might become quite tiresome. However, most often we collect multiple data points according to a single (or only a few different) observation scheme(s), in which case explicitly decorating each observation separately does not really seem to be necessary. To this end we provide a struct ObsScheme together with a function load_data for a convenient way of decorating multiple observations at once.","category":"page"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"ObservationSchemes.ObsScheme\nObservationSchemes.load_data","category":"page"},{"location":"manual/observation_schemes/#ObservationSchemes.ObsScheme","page":"Observation schemes","title":"ObservationSchemes.ObsScheme","text":"struct ObsScheme{T}\n    obs::T\n    pattern::Vector{Int64}\n    full_pattern::Vector{Int64}\n    mode::Val\nend\n\nA struct ObsScheme acts as a template for reading in multiple observations.\n\nobs: contains a list of all possible observation schemes according to which        the data (that are supposed to be loaded in) were recorded\npattern: specifies the order in which the list of obs is supposed to be            iterated through when reading in successive observations. Usually            the number of datapoint is larger than the length of pattern in            which case the pattern is cycled through repeatedly.\nfull_pattern: as pattern, but must be of the same length as the loaded in                 data.\nmode: if set to Val{:simple}(), then cycles through pattern. Otherwise         cycles through full_pattern.\n\nObsScheme(\n    obs...;\n    pattern=[1:length(obs)...],\n    full_pattern=[],\n    mode=Val(:simple)\n)\n\nBase constructor.\n\n\n\n\n\n","category":"type"},{"location":"manual/observation_schemes/#ObservationSchemes.load_data","page":"Observation schemes","title":"ObservationSchemes.load_data","text":"load_data(os::ObsScheme, tt, xx)\n\nDecorate the data in xx and times of recordings in tt according to an observation scheme template stored in os.\n\n\n\n\n\nload_data(os::ObsScheme, tt_xx)\n\nSame as load_data(os::ObsScheme, tt, xx), but tt_xx is a vector of tuples that pair the observations with their recorded times.\n\nload_data(os::ObsScheme, tt_xx_filename::String)\n\nSame as above, but tt_xx are stored in a .csv file named tt_xx_filename, with each row containing time t and its respective observation x stored back-to-back.\n\n\n\n\n\n","category":"function"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"For instance, if all data are collected according to a single observation scheme:","category":"page"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"t, v = 1.0, [1.0, 2.0, 3.0] # dummy values, only DataType matter\nobs = LinearGsnObs(t, v; full_obs=true)","category":"page"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"Then we can define it as an observation scheme and load the data as follows:","category":"page"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"# ----- raw data ------------------------#\ntt = [1.0, 2.0, 3.0, 4.0, 5.0]           #\nxx = [i.+rand(3) for i in eachindex(tt)] #\n# -------------------------------------- #\n\ndata = load_data(ObsScheme(obs), tt, xx)","category":"page"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"If more than one type of observation schemes are used then we can pass a list of them to ObsScheme, and then, specify the pattern in which they should be cycled through when loading in the data:","category":"page"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"# another observation scheme:\nt, v = 1.0, SVector{2,Float64}(1.0, 2.0)\nobs2 = LinearGsnObs(t, v; full_obs=true)\n\n# -------------------------------------- other raw data ------------------------#\nxx = [i%2==1 ? i.+rand(3) : i.+rand(SVector{2,Float64}) for i in eachindex(tt)] #\n# ------------------------------------------------------------------------------#\n\n# load the data:\ndata = load_data(ObsScheme(obs, obs2; pattern=[1,2]), tt, xx)\n# ↑ simply alternate between `obs` and `obs2`","category":"page"},{"location":"manual/observation_schemes/#Generating-data-directly-from-the-simulated-trajectory-1","page":"Observation schemes","title":"Generating data directly from the simulated trajectory","text":"","category":"section"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"","category":"page"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"Very often we need to simulate some data from the underlying model for testing purposes. To help ourselves a little with this process we can use","category":"page"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"collect(os::ObservationSchemes.ObsScheme, path, step=1, record_start_pt=false)","category":"page"},{"location":"manual/observation_schemes/#Base.collect","page":"Observation schemes","title":"Base.collect","text":"Base.collect(os::ObsScheme, path, step=1, record_start_pt=false)\n\nRecord observations from a raw trajectory path according to the observation scheme os. Collect 1 observation for every step many points in the raw data. If record_start_pt, then the starting is recorded, otherwise it is omitted. path should have fields .x and .t with the underlying process and times respectively.\n\n\n\n\n\n","category":"function"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"We only need to simulate the trajectory and define the observation scheme. Then, we can use collect to generate an appropriately decorated dataset from such raw recording.","category":"page"},{"location":"manual/observation_schemes/#example_for_obs_scheme-1","page":"Observation schemes","title":"Example","text":"","category":"section"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"For instance we can use the package DiffusionDefinition.jl to simulate a trajectory from the FitzHugh–Nagumo model:","category":"page"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"using DiffusionDefinition, StaticArrays\n@load_diffusion FitzHughNagumo\n\nP = FitzHughNagumo(0.1, -0.8, 1.5, 0.0, 0.3)\ntt = 0.0:0.0001:10.0\nx0 = @SVector [-0.6, -0.6]\nX = rand(P, tt, x0)","category":"page"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"then, define the observation scheme:","category":"page"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"obs_sch = ObsScheme(\n    LinearGsnObs(\n        0.0, (@SVector [0.0]);\n        L = (@SMatrix [1.0 0.0;]),\n        Σ = (@SMatrix [0.01;]),\n    )\n)","category":"page"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"and then very simply generate a dataset","category":"page"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"data = collect(obs_sch, X, 1000, false)","category":"page"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"Examining the first two and the last observation yield:","category":"page"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"julia> summary(data[1])\n⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤\n|Observation `v = Lx+ξ`, where `L` is a (1, 2)-matrix, `x` is a state of the stochastic process and `ξ`∼N(μ,Σ).\n|...\n|| ν: [-1.0821504043466732] (observation),\n||  → typeof(ν): SArray{Tuple{1},Float64,1,1},\n|| made at time 0.1.\n|...\n|L: [1.0 0.0],\n|   → typeof(L): SArray{Tuple{1,2},Float64,2,2}\n|μ: [0.0],\n|   → typeof(μ): SArray{Tuple{1},Float64,1,1}\n|Σ: [0.01],\n|   → typeof(Σ): SArray{Tuple{1,1},Float64,2,1}\n|...\n|This is NOT an exact observation.\n|...\n|It does not depend on any additional parameters.\n|...\n|No first passage times recorded.\n⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆\n\njulia> summary(data[2])\n⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤\n|Observation `v = Lx+ξ`, where `L` is a (1, 2)-matrix, `x` is a state of the stochastic process and `ξ`∼N(μ,Σ).\n|...\n|| ν: [-0.9679347555098883] (observation),\n||  → typeof(ν): SArray{Tuple{1},Float64,1,1},\n|| made at time 0.2.\n|...\n|L: [1.0 0.0],\n|   → typeof(L): SArray{Tuple{1,2},Float64,2,2}\n|μ: [0.0],\n|   → typeof(μ): SArray{Tuple{1},Float64,1,1}\n|Σ: [0.01],\n|   → typeof(Σ): SArray{Tuple{1,1},Float64,2,1}\n|...\n|This is NOT an exact observation.\n|...\n|It does not depend on any additional parameters.\n|...\n|No first passage times recorded.\n⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆\n\njulia> summary(data[end])\n⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤\n|Observation `v = Lx+ξ`, where `L` is a (1, 2)-matrix, `x` is a state of the stochastic process and `ξ`∼N(μ,Σ).\n|...\n|| ν: [0.8136510716798605] (observation),\n||  → typeof(ν): SArray{Tuple{1},Float64,1,1},\n|| made at time 10.0.\n|...\n|L: [1.0 0.0],\n|   → typeof(L): SArray{Tuple{1,2},Float64,2,2}\n|μ: [0.0],\n|   → typeof(μ): SArray{Tuple{1},Float64,1,1}\n|Σ: [0.01],\n|   → typeof(Σ): SArray{Tuple{1,1},Float64,2,1}\n|...\n|This is NOT an exact observation.\n|...\n|It does not depend on any additional parameters.\n|...\n|No first passage times recorded.\n⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆","category":"page"},{"location":"how_to_guides/dataframes/#How-to-work-with-dataframes?-1","page":"... work with dataframes?","title":"How to work with dataframes?","text":"","category":"section"},{"location":"how_to_guides/dataframes/#","page":"... work with dataframes?","title":"... work with dataframes?","text":"","category":"page"},{"location":"how_to_guides/dataframes/#","page":"... work with dataframes?","title":"... work with dataframes?","text":"DataFrames.jl is a very useful package for dealing with data. We don't use it explicitly in any packages of JuliaDiffusionBayes, however, it is likely that some users of JuliaDiffusionBayes packages will want to store their observations in a DataFrame.","category":"page"},{"location":"how_to_guides/dataframes/#","page":"... work with dataframes?","title":"... work with dataframes?","text":"If your raw data is stored in two columns:","category":"page"},{"location":"how_to_guides/dataframes/#","page":"... work with dataframes?","title":"... work with dataframes?","text":"raw_data = DataFrame(\n    t = [...],\n    x = [...],\n)","category":"page"},{"location":"how_to_guides/dataframes/#","page":"... work with dataframes?","title":"... work with dataframes?","text":"you can simply pass those two columns to load_data:","category":"page"},{"location":"how_to_guides/dataframes/#","page":"... work with dataframes?","title":"... work with dataframes?","text":"obs_scheme = ...\ndata = load_data(obs_scheme, raw_data.t, raw_data.x)","category":"page"},{"location":"how_to_guides/dataframes/#","page":"... work with dataframes?","title":"... work with dataframes?","text":"You may then construct a dataframe with your decorated data","category":"page"},{"location":"how_to_guides/dataframes/#","page":"... work with dataframes?","title":"... work with dataframes?","text":"df = DataFrame(data=data)","category":"page"},{"location":"how_to_guides/custom_os/#How-to-define-custom-observation-schemes?-1","page":"... define custom observation schemes?","title":"How to define custom observation schemes?","text":"","category":"section"},{"location":"how_to_guides/custom_os/#","page":"... define custom observation schemes?","title":"... define custom observation schemes?","text":"","category":"page"},{"location":"how_to_guides/custom_os/#","page":"... define custom observation schemes?","title":"... define custom observation schemes?","text":"To define custom observation schemes use the struct GeneralObs. You can read more about it here. It allows you to define any observation scheme.","category":"page"},{"location":"how_to_guides/custom_os/#","page":"... define custom observation schemes?","title":"... define custom observation schemes?","text":"tip: Tip\nBy default GeneralObs requires from the user to pass a LinearGsnObs approximation to the GeneralObs. This is meant to be used in an MCMC setting, when such an approximation is necessary. However, if your application does not require LinearGsnObs approximation, then simply pass an irrelevant instance of LinearGsnObs to a constructor of GeneralObs (or define a custom constructor for GeneralObs that does not require from the user for LinearGsnObs to be passed, and instead, creates and passes an irrelevant instance of LinearGsnObs internally).","category":"page"},{"location":"how_to_guides/other_processes/#How-to-deal-with-stochastic-processes-other-than-diffusions?-1","page":"... deal with stochastic processes other than diffusions?","title":"How to deal with stochastic processes other than diffusions?","text":"","category":"section"},{"location":"how_to_guides/other_processes/#","page":"... deal with stochastic processes other than diffusions?","title":"... deal with stochastic processes other than diffusions?","text":"","category":"page"},{"location":"how_to_guides/other_processes/#","page":"... deal with stochastic processes other than diffusions?","title":"... deal with stochastic processes other than diffusions?","text":"In JuliaDiffusionBayes we work mostly with diffusion processes and we have also explicitly used an example with diffusion processes here in this documentation. However, the source code of ObservationSchemes.jl does not make any assumptions at any point about the type of underlying law that generated the data. Consequently, it makes no difference whatsoever to ObservationSchemes.jl whether your observations come from a diffusion process or from some other stochastic process. The onus is on the user to specify an appropriate law for the stochastic process when defining a recording.","category":"page"},{"location":"how_to_guides/other_processes/#","page":"... deal with stochastic processes other than diffusions?","title":"... deal with stochastic processes other than diffusions?","text":"In fact, you don't even need to be dealing with stochastic processes. You might as well have iid distributions of some random variable. In that case, simply make sure that your law is well-defined and then pass your observations with some dummy time-variable (doing the same for the starting point).","category":"page"},{"location":"#ObservationSchemes.jl-1","page":"Home","title":"ObservationSchemes.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This is a utility package belonging to a suite of packages in JuliaDiffusionBayes. Its purpose is to provide a systematic way of encoding discrete-time observations for stochastic processes. However, in principle, it can also be used in more general contexts, for observations that were not generated by stochastic processes.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The underlying idea behind the package is to provide a set of decorators that may be used to equip each data-point separately, and in doing so, describe how a given data-point has been recorded. This flexible framework can be used to define complex observation schemes in a simple way.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The following types of observations can be defined with this package:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Exact observations of all or a subset of all coordinates of the underlying process\nLinear translations of the underlying process, disturbed by Gaussian noise\nFirst-passage time observations\nFirst-passage time observations with additional resetting events\nNon-linearly (or linearly) transformed observations with Gaussian or non-Gaussian noise\nParameterized versions of all observation types above","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Additionally, the package provides functionality to couple multiple observations together, so as to define:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Multiple observations of a single process\nMultiple observations of multiple processes, coming possibly from different laws that share subsets of parameters (mixed-effect models)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Finally, we provide infrastructure for defining priors over starting points. In particular we add concrete implementations of","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Degenerate priors corresponding to fixed starting points\nGaussian priors","category":"page"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Depending on your intended use of this package you might choose to start at different places:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For a quick overview of ObservationSchemes.jl's main functionality see Get started\nFor a systematic introduction to all functionality introduced in this package see the Manual\nFor a didactic introduction to problems that can be solved using ObservationSchemes.jl see the Tutorials\nIf you have a problem that you think can be addressed with this package, then check out the How-to guides to see if the answer is already there.","category":"page"}]
}
