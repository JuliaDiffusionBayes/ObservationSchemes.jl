var documenterSearchIndex = {"docs":
[{"location":"module_index/#ObservationSchemes.jl-1","page":"Index","title":"ObservationSchemes.jl","text":"","category":"section"},{"location":"module_index/#","page":"Index","title":"Index","text":"","category":"page"},{"location":"module_index/#","page":"Index","title":"Index","text":"Modules = [ObservationSchemes]","category":"page"},{"location":"module_index/#ObservationSchemes.FirstPassageTimeInfo","page":"Index","title":"ObservationSchemes.FirstPassageTimeInfo","text":"FirstPassageTimeInfo{C,L,U,A} <: FirstPassageAbstract\n\nCompile-time indicator for the first-passage time information conveyed by the data-point. C lists the affected coordinates (of the observations, not the process), L indicates the level, U are indicators for whether the respective first-passage times are up-crossings and A is and indicator for whether an additional reset needs to be reached before first-passage time (note that reset time is defined as a first-passage time to a corresponding reset level stored in R that happens anytime before the actual first-passage time, the reset-time happens in the direction opposite to the direction of first-passage time crossing; additionally, the coordinate can reach the first-passage time level prior to being reset).\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ObservationSchemes.GsnStartingPt-Tuple{Any,Any}","page":"Index","title":"ObservationSchemes.GsnStartingPt","text":"GsnStartingPt(μ::T, Σ::S)\n\nBase constructor of GsnStartingPt. It initialises the mean μ and covariance Σ parameters and Λ is set according to Λ:=Σ⁻¹\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.NoFirstPassageTimes","page":"Index","title":"ObservationSchemes.NoFirstPassageTimes","text":"NoFirstPassageTimes <: FirstPassageAbstract\n\nCompile-time indicator that the observation stores no first-passage time data\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ObservationSchemes.add_dependency!-Tuple{AllObservations,Dict}","page":"Index","title":"ObservationSchemes.add_dependency!","text":"add_dependency!(all_obs::AllObservations, dep::Dict)\n\nAdd a dependency structure dep between parameters shared across various laws and observations used to generate various recordings stored in an observations container all_obs.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.add_recording!-Tuple{AllObservations,NamedTuple}","page":"Index","title":"ObservationSchemes.add_recording!","text":"add_recording!(all_obs::AllObservations, recording::NamedTuple)\n\nAdd a new recording recording to observations container all_obs.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.fpt_info-Union{Tuple{LinearGsnObs{Tag,D,T,FPT,TL,Tμ,TΣ,K} where K where TΣ where Tμ where TL}, Tuple{FPT}, Tuple{T}, Tuple{D}, Tuple{Tag}} where FPT where T where D where Tag","page":"Index","title":"ObservationSchemes.fpt_info","text":"fpt_info(::LinearGsnObs{D,T,Tag,FPT}) where {D,T,Tag,FPT}\n\nReturn information about first-passage times\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.initialize-Tuple{AllObservations}","page":"Index","title":"ObservationSchemes.initialize","text":"initialize(all_obs::AllObservations)\n\nSplit the recordings at the times of full observations to make full use of the Markov property (and make the code readily parallelisable). Introduce all parameters that were not mentioned in the current dependency dictionary. Create dictionaries that allow for efficient retreival of all laws and observations that depend on any specified parameter\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.load_data-Tuple{ObsScheme,Any,Any}","page":"Index","title":"ObservationSchemes.load_data","text":"load_data(os::ObsScheme, tt, xx)\n\nDecorate the data in xx and times of recordings in tt according to an observation scheme template stored in os.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.load_data-Tuple{ObsScheme,Any}","page":"Index","title":"ObservationSchemes.load_data","text":"load_data(os::ObsScheme, tt_xx)\n\nSame as load_data(os::ObsScheme, tt, xx), but tt_xx is a vector of tuples that pair the observation with its recorded time.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.FirstPassageAbstract","page":"Index","title":"ObservationSchemes.FirstPassageAbstract","text":"FirstPassageAbstract\n\nTypes ihneriting from this struct define the type of information stored about first-passage times\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ObservationSchemes.ParametrizedObservation","page":"Index","title":"ObservationSchemes.ParametrizedObservation","text":"ParametrizedObservation{D,T} <: Observation{D,T}\n\nSame as observations but additionally, types inheriting from this struct depend on some parameters (that may in practice be unknown).\n\n\n\n\n\n","category":"type"},{"location":"module_index/#Base.eltype-Union{Tuple{K}, Tuple{K}, Tuple{T}, Tuple{D}} where K<:ObservationSchemes.Observation{D,T} where T where D","page":"Index","title":"Base.eltype","text":"eltype(::K) where {K<:Observation{D,T}}\n\nEltype of the observation.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#Base.length-Union{Tuple{K}, Tuple{K}, Tuple{D}} where K<:(ObservationSchemes.Observation{D,T} where T) where D","page":"Index","title":"Base.length","text":"length(::K) where {K<:Observation{D}}\n\nLength of the observation (equal to a number of entries in a vector holding the data)\n\n\n\n\n\n","category":"method"},{"location":"module_index/#Base.rand","page":"Index","title":"Base.rand","text":"rand([rng::Random.AbstractRNG], G::GsnStartingPt, z, ρ=0.0)\n\nSample new white noise using Crank-Nicolson scheme with memory parameter ρ and a previous value of the white noise stored inside object G\n\n\n\n\n\n","category":"function"},{"location":"module_index/#Base.rand-Tuple{Random.AbstractRNG,GsnStartingPt}","page":"Index","title":"Base.rand","text":"rand([rng::Random.AbstractRNG], G::GsnStartingPt)\n\nSample new starting point according to its prior distribution.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#Base.rand-Tuple{Random.AbstractRNG,KnownStartingPt,Vararg{Any,N} where N}","page":"Index","title":"Base.rand","text":"rand([rng::Random.AbstractRNG], G::KnownStartingPt, args...)\n\nStarting point is known. Nothing can be sampled. Returning known starting point.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#Base.size-Union{Tuple{K}, Tuple{K}, Tuple{D}} where K<:(ObservationSchemes.Observation{D,T} where T) where D","page":"Index","title":"Base.size","text":"size(::K) where {K<:Observation{D}}\n\nSize of the observation\n\n\n\n\n\n","category":"method"},{"location":"module_index/#Distributions.logpdf-Tuple{GsnStartingPt,Any}","page":"Index","title":"Distributions.logpdf","text":"logpdf(::GsnStartingPt, y)\n\nlog-probability density function evaluated at y of a prior distribution G\n\n\n\n\n\n","category":"method"},{"location":"module_index/#Distributions.logpdf-Tuple{KnownStartingPt,Any}","page":"Index","title":"Distributions.logpdf","text":"logpdf(::KnownStartingPt, y)\n\nNothing to do so long as y is equal to the known starting point inside G\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.L-Tuple{LinearGsnObs}","page":"Index","title":"ObservationSchemes.L","text":"L(o::LinearGsnObs)\n\nReturn matrix L from the observation scheme ν = Lx+ξ, where ξ∼N(μ,Σ)\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.check_recording_format-Union{Tuple{T}, Tuple{T}} where T<:NamedTuple","page":"Index","title":"ObservationSchemes.check_recording_format","text":"check_recording_format(::T) where T<:NamedTuple\n\nCheck whether the namedtuple has fields P, obs, t0 and x0_prior that each recording must have.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.fill_dependency_for_unspec_params_and_obs-Tuple{AllObservations}","page":"Index","title":"ObservationSchemes.fill_dependency_for_unspec_params_and_obs","text":"fill_dependency_for_unspec_params(all_obs::AllObservations)\n\nFill the all_obs.depen_param dictionary with all parameters that are not shared between recordings.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.inv_start_pt-Tuple{Any,GsnStartingPt,Any}","page":"Index","title":"ObservationSchemes.inv_start_pt","text":"inv_start_pt(y, G::GsnStartingPt, P)\n\nCompute the driving noise that is needed to obtain starting point y under prior G and the likelihood in P\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.inv_start_pt-Tuple{Any,KnownStartingPt,Any}","page":"Index","title":"ObservationSchemes.inv_start_pt","text":"inv_start_pt(y, G::KnownStartingPt, P)\n\nStarting point known, no need for dealing with white noise, use convention of returning y\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.local_symbols-Union{Tuple{T}, Tuple{AllObservations,AbstractArray{#s20,N} where N where #s20<:AbstractArray,Function,Array{Symbol,1}}} where T","page":"Index","title":"ObservationSchemes.local_symbols","text":"local_symbols(\n    all_obs::AllObservations,\n    objects::AbstractArray{<:AbstractArray},\n    f::Function,\n    θsym::Vector{Symbol}\n) where T\n\nobjects is usually an array of arrays that must in total have the same number of elements as there are observations in the recording. It may however have a different jagged structure. The output is of the same structure as objects and gives for each o in object a corresponding lists of parameters and observations it depends on.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.new_obs_dependence!-Tuple{Any,Any}","page":"Index","title":"ObservationSchemes.new_obs_dependence!","text":"new_obs_dependence!(old_dep, old_to_new_idx)\n\nCreate a new interdependency dictionary for the observations from the old one old_dep and the dictionary old_to_new_idx that kept track of the changes.\n\nExample\n\nold_dep = Dict(\n    :A => [(1, 2, 1), (1, 3, 2), (2, 1, 1)],\n    :B => [(2, 2, 2), (3, 2, 1)],\n)\nold_to_new_idx = Dict(\n    (1,1) => (1, 1), # obs (1,1) becomes (1,1)\n    (1,2) => (1, 2),\n    (1,3) => (2, 1), # obs (1,3) becomes (2,1)\n    (2,1) => (3, 1),\n    (2,2) => (4, 1),\n    (2,3) => (5, 1),\n    (3,1) => (6, 1),\n    (3,2) => (6, 2),\n)\n\nnew_dep = new_obs_dependence!(old_dep, old_to_new_idx)\n\nnew_dep == Dict(\n    :A => [(1, 2, 1), (2, 1, 2), (3, 1, 1)],\n    :B => [(4, 1, 2), (6, 2, 1)]\n)\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.new_param_and_obs_dependence!-NTuple{5,Any}","page":"Index","title":"ObservationSchemes.new_param_and_obs_dependence!","text":"new_param_and_obs_dependence!(\n    out,\n    old_p_dep,\n    old_o_dep,\n    old_to_new_idx,\n    old_to_new_obs_idx\n)\n\nTODO refresh Define a new parameter dependence structure by using an old parameter dependence saved in old_dep and deducing the changed indices of affected recording by following the old_to_new_idx dictionary. The new dependency is saved directly to out structure.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.new_param_dependence!-Tuple{Any,Any}","page":"Index","title":"ObservationSchemes.new_param_dependence!","text":"new_param_dependence!(old_dep, old_to_new_idx)\n\nCreate a new interdependency dictionary for the parameters from the old one old_dep and the dictionary old_to_new_idx that kept track of the changes.\n\nExamples\n\nold_dep = Dict(\n    :A => [(1, :a), (2, :a1)],\n    :B => [(1, :b), (3, :bbb)],\n)\nold_to_new_idx = Dict(\n    1 => [1, 2], # observation 1 was split into two\n    2 => [3, 4, 5], # observation 2 was split into three\n    3 => [6],\n)\n\nnew_dep = new_param_dependence!(old_dep, old_to_new_idx)\n\nnew_dep == Dict(\n    :A => [1=>:a, 2=>:a, 3=>:a1, 4=>:a1, 5=>:a1],\n    :B => [1=>:b, 2=>:b, 6=>:bbb],\n)\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.parameter_names","page":"Index","title":"ObservationSchemes.parameter_names","text":"parameter_names\n\nReturn names of the parameters of a given object\n\n\n\n\n\n","category":"function"},{"location":"module_index/#ObservationSchemes.print_parameters-Tuple{AllObservations}","page":"Index","title":"ObservationSchemes.print_parameters","text":"print_parameters(all_obs::AllObservations)\n\nPrint information about the variable parameters about which the all_obs.param_depend object stores some interdependency information.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.split_recording!-Tuple{Any,Any,Any,AllObservations,Any,Any}","page":"Index","title":"ObservationSchemes.split_recording!","text":"split_recording!(\n        recording_idx,\n        recording,\n        counter,\n        out::AllObservations,\n        old_to_new_idx,\n        old_to_new_obs_idx,\n    )\n\nSplit a single record recording at the times of full observations. Save new, splitted recordings in the struct out. Keep account of the changed indices of the recordings for the recording index <---> parameter dependence pairs by updating a suitable dictionary old_to_new_idx, starting the new recording's index at an offset counter.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.start_pt-Tuple{Any,GsnStartingPt,Any}","page":"Index","title":"ObservationSchemes.start_pt","text":"start_pt(z, G::GsnStartingPt, P)\n\nCompute a new starting point from the white noise for a given posterior distribution obtained from combining prior G and the likelihood encoded by the object P.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.start_pt-Tuple{Any,GsnStartingPt}","page":"Index","title":"ObservationSchemes.start_pt","text":"start_pt(z, G::GsnStartingPt)\n\nCompute a new starting point from the white noise for a given prior distribution G\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.start_pt-Tuple{Any,KnownStartingPt,Any}","page":"Index","title":"ObservationSchemes.start_pt","text":"start_pt(z, G::KnownStartingPt, P)\n\nReturn starting point\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.start_pt-Tuple{KnownStartingPt,Any}","page":"Index","title":"ObservationSchemes.start_pt","text":"start_pt(G::KnownStartingPt, P)\n\nReturn starting point\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.Λ-Tuple{LinearGsnObs}","page":"Index","title":"ObservationSchemes.Λ","text":"Λ(o::LinearGsnObs)\n\nReturn matrix Λ:=Σ⁻¹ from the observation scheme ν = Lx+ξ, where ξ∼N(μ,Σ)\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.Σ-Tuple{LinearGsnObs}","page":"Index","title":"ObservationSchemes.Σ","text":"Σ(o::LinearGsnObs)\n\nReturn matrix Σ from the observation scheme ν = Lx+ξ, where ξ∼N(μ,Σ)\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.μ-Tuple{LinearGsnObs}","page":"Index","title":"ObservationSchemes.μ","text":"μ(o::LinearGsnObs)\n\nReturn vector μ from the observation scheme ν = Lx+ξ, where ξ∼N(μ,Σ)\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.ν-Tuple{ObservationSchemes.Observation}","page":"Index","title":"ObservationSchemes.ν","text":"ν(o::Observation)\n\nReturn the observation\n\n\n\n\n\n","category":"method"},{"location":"get_started/overview/#get_started-1","page":"Get started","title":"Installation","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"The package is not registered yet. To install it write:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"] add https://github.com/JuliaDiffusionBayes/ObservationSchemes.jl","category":"page"},{"location":"get_started/overview/#A-single-observation-1","page":"Get started","title":"A single observation","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"To define a single observation collected according to","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"V_t = LX_t+xiquad xisim N(muSigma)","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"call","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"using LinearAlgebra\nν = [1.0, 2.0, 3.0]\nt = 2.0\nL = [1.0 0.0 2.0 0.0; 3.0 4.0 0.0 0.0; 0.0 1.0 0.0 1.0]\nΣ = Diagonal([1.0, 1.0, 1e-11])\nobs = LinearGsnObs(t, ν; L = L, Σ = Σ) # μ is defaulted to 0","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"For a general observation scheme:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"V_t = g(X_t) + xiquad xisim Xi","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"you may use GeneralObs instead of LinearGsnObs, but you must provide the function g, the law Xi (and an approximation via LinearGsnObs if you wish to use it with other packages in DiffusionBayes).","category":"page"},{"location":"get_started/overview/#Multiple-observations-1","page":"Get started","title":"Multiple observations","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"To define multiple observations at once define a list of observation formats in which the data was collected:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"# type 1\nt, v = 1.0, [1.0, 2.0, 3.0] # dummy values, only DataType matter\nobs = LinearGsnObs(t, v; full_obs=true)\n\n# type 2, i.e. another observation scheme:\nt, v = 1.0, SVector{2,Float64}(1.0, 2.0)\nobs2 = LinearGsnObs(t, v; full_obs=true)\n\n# data defined externally:\ntt, xx = ...\n\n# decorate the data\nobservs = load_data(ObsScheme(obs, obs2; pattern=[1,2]), tt, xx)","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"These can then be put in a container that collects observations of multiple trajectories:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"all_obs = AllObservations()\nadd_recording!(\n    all_obs,\n    (\n        P = ...,\n        obs = observs,\n        t0 = ...,\n        x0_prior = ...,\n    )\n)","category":"page"},{"location":"get_started/overview/#Define-interdependence-structure-for-parameters-1","page":"Get started","title":"Define interdependence structure for parameters","text":"","category":"section"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"If your data consist of recordings of multiple trajectories, sampled under laws that share some subsets of parameters or observation schemes sharing some parameters, then you may wish to specify the interdependence structure. To this end you may use add_dependency! function:","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"add_dependency!(\n    all_obs,\n    Dict(\n    :α_shared => [(rec=1, law_else_obs=true, p_name=:α), (rec=2, law_else_obs=true, p_name=:α)],\n    :β_shared => [(rec=1, law_else_obs=true, p_name=:β), (rec=2, law_else_obs=true, p_name=:β)],\n    )\n)","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"Once you're done setting up an instance of AllObservations call initialize to build some useful internal structures for fast iteration over interdependence structure.","category":"page"},{"location":"get_started/overview/#","page":"Get started","title":"Get started","text":"initialised_all_obs, old_to_new_idx = initialize(all_obs)","category":"page"},{"location":"manual/single_observation/#manual_start-1","page":"A single observation","title":"Observation schemes","text":"","category":"section"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"All observation schemes inherit from","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"ObservationSchemes.Observation","category":"page"},{"location":"manual/single_observation/#ObservationSchemes.Observation","page":"A single observation","title":"ObservationSchemes.Observation","text":"Observation{D,T}\n\nTypes inheriting from this struct provide all information about the observation of the stochastic process being made. D denotes the dimension of the observation whereas T its eltype.\n\n\n\n\n\n","category":"type"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"and must have methods","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"ObservationSchemes.eltype\nObservationSchemes.size\nObservationSchemes.length","category":"page"},{"location":"manual/single_observation/#Base.eltype","page":"A single observation","title":"Base.eltype","text":"eltype(::K) where {K<:Observation{D,T}}\n\nEltype of the observation.\n\n\n\n\n\n","category":"function"},{"location":"manual/single_observation/#Base.size","page":"A single observation","title":"Base.size","text":"size(::K) where {K<:Observation{D}}\n\nSize of the observation\n\n\n\n\n\n","category":"function"},{"location":"manual/single_observation/#Base.length","page":"A single observation","title":"Base.length","text":"length(::K) where {K<:Observation{D}}\n\nLength of the observation (equal to a number of entries in a vector holding the data)\n\n\n\n\n\n","category":"function"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"implemented for them. The idea is to decorate each recorded data-point with such structs, and in doing so, encode the way in which it was collected.","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"We implemented two concrete structs that may be used for defining a single observation:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"LinearGsnObs: to encode observations of the linear transformations of the underlying process disturbed by Gaussian noise\nGeneralObs: to encode observations of non-linear transformations of the underlying process disturbed by noise.","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"Both admit a possibility of parameterization.","category":"page"},{"location":"manual/single_observation/#Linear-Gaussian-struct-1","page":"A single observation","title":"Linear Gaussian struct","text":"","category":"section"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"The most important observation scheme is LinearGsnObs.  It is suitable for representing observations that can be written in the following format:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"beginequationlabeleqobs_scheme\nV_t = LX_t+xiquad xisim N(μΣ)\nendequation","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"where LinRR^dtimes d and X_t is a state of the underlying stochastic process.","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"ObservationSchemes.LinearGsnObs","category":"page"},{"location":"manual/single_observation/#ObservationSchemes.LinearGsnObs","page":"A single observation","title":"ObservationSchemes.LinearGsnObs","text":"struct LinearGsnObs{Tag,D,T,FPT,S,R,K} <: Observation{D,T}\n    L::S\n    μ::T\n    Σ::R\n    obs::T\n    t::Float64\n    full_obs::Bool\n    θ::Vector{K}\nend\n\nObservation of the underlying process that is of the form: LX+ξ, where ξ∼N(μ,Σ) and L,Σ and μ are respectively matrices and a vector of appropriate dimensions. FPT stores information about first-passage times. full_obs is an indicator for whether it is a full observation of the process (as it grants the use of Markov Property). θ is a container that may contain parameters that enter L, μ, Σ and Tag is a disambiguation flag used at compile time or for multiple dispatch to differentiate between different observation types.\n\n\n\n\n\n","category":"type"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"Below, we list some special cases of the scheme above.","category":"page"},{"location":"manual/single_observation/#Exact-observations-of-the-process-1","page":"A single observation","title":"Exact observations of the process","text":"","category":"section"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"A degenerate case of the setting above is an exact observation of X_t, i.e. when","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"L = I_dqquad μ = 0_dtimes 1qquad Σ = 0_dtimes d","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"so that X_t=V_t. This can be defined as:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"t, v = 1.0, [1.0, 2.0, 3.0]\nobs = LinearGsnObs(t, v; full_obs=true)","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"warning: Warning\nFor numerical reasons the covariance matrix of the noise Σ should not be a zero matrix, and instead, even in the exact observation setting should be inflated by some small artificial noise. By default Σ is set to Sigma=10^-11I_d for numerical reasons. This can be changed by specifying Σ explicitly, for instance to increase the level of artificial noise:using LinearAlgebra\nobs = LinearGsnObs(t, v; Σ=(1e-5)I, full_obs=true)","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"Specifying full_obs=true is important, as it lets the compiler differentiate between an actual, full observation with some artificial noise and a (possibly) partial observation with very low level (or also artificial level) of noise. As a result, Julia knows when the Markov property can be applied!","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"We can view a summary of the observation by calling summary:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"julia> summary(obs)\n⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤\n|Observation `v = Lx+ξ`, where `L` is a (3, 3)-matrix, `x` is a state of the stochastic process and `ξ`∼N(μ,Σ).\n|...\n|| v: [1.0, 2.0, 3.0] (observation),\n||  → typeof(v): Array{Float64,1},\n|| made at time 1.0.\n|...\n|L: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0],\n|   → typeof(L): Diagonal{Float64,Array{Float64,1}}\n|μ: [0.0, 0.0, 0.0],\n|   → typeof(μ): Array{Float64,1}\n|Σ: [1.0e-11 0.0 0.0; 0.0 1.0e-11 0.0; 0.0 0.0 1.0e-11],\n|   → typeof(Σ): Diagonal{Float64,Array{Float64,1}}\n|...\n|This is an exact observation.\n|...\n|It does not depend on any additional parameters.\n|...\n|No first passage times recorded.\n⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"Notice that various defaults and type-inferences have kicked in. It was recognized that the observation does not depend on any parameters, that first-passage time setting does not apply and that the observation was a mutable type and hence regular Arrays are used to define L, μ and Σ.","category":"page"},{"location":"manual/single_observation/#standard_example_lingsnobs-1","page":"A single observation","title":"Linear transformations of the process disturbed by Gaussian noise","text":"","category":"section"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"This is a standard understanding of the expression in \\eqref{eq:obs_scheme}. An example could be:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"using StaticArrays\nv = @SVector [1.0, 2.0, 3.0]\nt = 2.0\nL = @SMatrix [1.0 0.0 2.0 0.0; 3.0 4.0 0.0 0.0; 0.0 1.0 0.0 1.0]\nΣ = SDiagonal(1.0, 1.0, 1e-11)\nobs = LinearGsnObs(t, v; L = L, Σ = Σ)","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"for defining a three-dimensional observation v made at time 20 of a four-dimensional process X, where the first coordinate of the observation is X_t^1+2X_t^3+xi^1, with xi^1sim N(01), the second coordinate is 3X_t^1+4X_t^2+xi^2, with xi^2sim N(01), and the third coordinate is X_t^2+X_t^4, with no real noise (only artificial one, needed for numerical reasons). We can display the summary of the observation with:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"julia> summary(obs)\n⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤\n|Observation `v = Lx+ξ`, where `L` is a (3, 4)-matrix, `x` is a state of the stochastic process and `ξ`∼N(μ,Σ).\n|...\n|| v: [1.0, 2.0, 3.0] (observation),\n||  → typeof(v): SArray{Tuple{3},Float64,1,3},\n|| made at time 2.0.\n|...\n|L: [1.0 0.0 2.0 0.0; 3.0 4.0 0.0 0.0; 0.0 1.0 0.0 1.0],\n|   → typeof(L): SArray{Tuple{3,4},Float64,2,12}\n|μ: [0.0, 0.0, 0.0],\n|   → typeof(μ): SArray{Tuple{3},Float64,1,3}\n|Σ: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0e-11],\n|   → typeof(Σ): Diagonal{Float64,SArray{Tuple{3},Float64,1,3}}\n|...\n|This is NOT an exact observation.\n|...\n|It does not depend on any additional parameters.\n|...\n|No first passage times recorded.\n⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"Note that the internal containers are now set to be SVectors (even μ, which wasn't passed to a constructor but its type was inferred and its value set to zero). Additionally, Julia understands that this is not a full observation and hence Markov property cannot be applied.","category":"page"},{"location":"manual/single_observation/#first_passage_time-1","page":"A single observation","title":"First-passage time observations","text":"","category":"section"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"Support for certain first-passage time settings is provided. By default LinearGsnObs sets the first-passage time info to NoFirstPassageTimes. However, this can be changed. For instance, to indicate in the example above that the last coordinate of v actually reaches level 30 for the very first time at time 10 we can specify the following:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"t, v = 1.0, [1.0, 2.0, 3.0]\nfpt = FirstPassageTimeInfo(\n    (3,),\n    (3.0,),\n    (true,),\n    (false,),\n    (),\n)\nobs = LinearGsnObs(t, v; L = L, Σ = Σ, fpt = fpt)","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"The last two entries in fpt specify additional reset times. For instance, instead of (false,) and () we could set (true,), (-1.0) to indicate that the process X_t^2+X_t^4 can do whatever before it falls below level -10 (in particular it can go above level 30), and that once it falls below -10, then from then on the first time it reaches level 30 happens at time 10. Note that","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"julia> summary(obs)\n⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤\n|Observation `v = Lx+ξ`, where `L` is a (3, 4)-matrix, `x` is a state of the stochastic process and `ξ`∼N(μ,Σ).\n|...\n|| v: [1.0, 2.0, 3.0] (observation),\n||  → typeof(v): Array{Float64,1},\n|| made at time 1.0.\n|...\n|L: [1.0 0.0 2.0 0.0; 3.0 4.0 0.0 0.0; 0.0 1.0 0.0 1.0],\n|   → typeof(L): SArray{Tuple{3,4},Float64,2,12}\n|μ: [0.0, 0.0, 0.0],\n|   → typeof(μ): Array{Float64,1}\n|Σ: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0e-11],\n|   → typeof(Σ): Diagonal{Float64,SArray{Tuple{3},Float64,1,3}}\n|...\n|This is NOT an exact observation.\n|...\n|It does not depend on any additional parameters.\n|...\n|First passage times of the observation `v`:\n|----------------------------------------------------------------------------\n||  coordinate  |     level    |  up-crossing |  extra reset |  reset level |\n|----------------------------------------------------------------------------\n||       3      |      3.0     |  up-crossing |       ✘      |       ✘      |\n⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"changes appropriately to display the new summary of the first-passage time information.","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"note: Note\nThis package is agnostic with respect to the algorithms that are later used on the decorated observations. Consequently it doesn't make any checks for whether the observations make sense. For instance in the package GuidedProposals.jl that deals with simulating conditioned diffusions, a support for first-passage time observations is currently extended only to diffusions  where the dynamics of the coordinate whose first-passage time is observed is devoid of any Wiener noise. The onus of checking whether this or other constraints are satisfied are on the user.","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"tip: Why do we refer to `LinearGsnObs` as most important?\nIn practice, all other observation schemes are handled by approximating them with a suitable LinearGsnObs and then correcting the resulting approximation error with Metropolis-Hastings steps. Consequently, LinearGsnObs will be a building block of any other observation scheme.","category":"page"},{"location":"manual/single_observation/#Parameterizing-LinearGsnObs-1","page":"A single observation","title":"Parameterizing LinearGsnObs","text":"","category":"section"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"The observations can be parameterized by passing a vector of parameters θ. Additionally, a Tag needs to be attached that is used to differentiate at compile time between the non-parameterized observations and parameterized observations as well as among different parameterizations themselves.","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"For instance, to indicate in the second example that two entries in the L matrix are parameterized we can write:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"v = @SVector [1.0, 2.0, 3.0]\nt = 2.0\nL = @SMatrix [1.0 0.0 -99.9 0.0; 3.0 4.0 0.0 0.0; 0.0 -99.9 0.0 1.0]\nΣ = SDiagonal(1.0, 1.0, 1e-11)\nobs = LinearGsnObs(t, v; L = L, Σ = Σ, θ=[2.0, 1.0], Tag=1)","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"We are not done yet, in this case matrix L that we passed above is incomplete as we intend to create an actual matrix L by combining the matrix and the parameters we've passed. To this end, we must overwrite the behaviour of the function L(⋅):","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"const OBS = ObservationSchemes\nfunction OBS.L(o::LinearGsnObs{1})\n    _L = MMatrix{3,4,Float64}(o.L)\n    _L[1,3] = o.θ[1]\n    _L[3,2] = o.θ[2]\n    SMatrix{3,4,Float64}(_L)\nend","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"Notice that we dispatch on the observation's tag 1. Furthermore, when calling summarize matrix L is displayed correctly.","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"julia> summary(obs)\n⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤\n|Observation `v = Lx+ξ`, where `L` is a (3, 4)-matrix, `x` is a state of the stochastic process and `ξ`∼N(μ,Σ).\n|...\n|| ν: [1.0, 2.0, 3.0] (observation),\n||  → typeof(ν): SArray{Tuple{3},Float64,1,3},\n|| made at time 2.0.\n|...\n|L: [1.0 0.0 2.0 0.0; 3.0 4.0 0.0 0.0; 0.0 1.0 0.0 1.0],\n|   → typeof(L): SArray{Tuple{3,4},Float64,2,12}\n|μ: [0.0, 0.0, 0.0],\n|   → typeof(μ): SArray{Tuple{3},Float64,1,3}\n|Σ: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0e-11],\n|   → typeof(Σ): Diagonal{Float64,SArray{Tuple{3},Float64,1,3}}\n|...\n|This is NOT an exact observation.\n|...\n|It depends on additional parameters, which are set to: (2.0, 1.0).\n|...\n|No first passage times recorded.\n⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"However, now we can change parameters to new values and the matrix L will be updated:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"OBS.update_params!(obs, [7.0, 8.0])\njulia> summary(obs)\n⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤\n|Observation `v = Lx+ξ`, where `L` is a (3, 4)-matrix, `x` is a state of the stochastic process and `ξ`∼N(μ,Σ).\n|...\n|| ν: [1.0, 2.0, 3.0] (observation),\n||  → typeof(ν): SArray{Tuple{3},Float64,1,3},\n|| made at time 2.0.\n|...\n|L: [1.0 0.0 7.0 0.0; 3.0 4.0 0.0 0.0; 0.0 8.0 0.0 1.0],\n|   → typeof(L): SArray{Tuple{3,4},Float64,2,12}\n|μ: [0.0, 0.0, 0.0],\n|   → typeof(μ): SArray{Tuple{3},Float64,1,3}\n|Σ: [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0e-11],\n|   → typeof(Σ): Diagonal{Float64,SArray{Tuple{3},Float64,1,3}}\n|...\n|This is NOT an exact observation.\n|...\n|It depends on additional parameters, which are set to: (7.0, 8.0).\n|...\n|No first passage times recorded.\n⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"note: Note\nWe used number -99.9 just to remind ourselves that entries with this number need to be overwritten by parameters. There are however no rules or enforcements as to how the user deals with such entries.","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"Notice that trying to access L via obs.L will give you an incorrect result. To avoid such mistakes, always query L, μ,Σ and obs via accessors:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"ObservationSchemes.L\nObservationSchemes.μ\nObservationSchemes.Σ\nObservationSchemes.ν\nObservationSchemes.obs","category":"page"},{"location":"manual/single_observation/#ObservationSchemes.L","page":"A single observation","title":"ObservationSchemes.L","text":"L(o::LinearGsnObs)\n\nReturn matrix L from the observation scheme ν = Lx+ξ, where ξ∼N(μ,Σ)\n\n\n\n\n\n","category":"function"},{"location":"manual/single_observation/#ObservationSchemes.μ","page":"A single observation","title":"ObservationSchemes.μ","text":"μ(o::LinearGsnObs)\n\nReturn vector μ from the observation scheme ν = Lx+ξ, where ξ∼N(μ,Σ)\n\n\n\n\n\n","category":"function"},{"location":"manual/single_observation/#ObservationSchemes.Σ","page":"A single observation","title":"ObservationSchemes.Σ","text":"Σ(o::LinearGsnObs)\n\nReturn matrix Σ from the observation scheme ν = Lx+ξ, where ξ∼N(μ,Σ)\n\n\n\n\n\n","category":"function"},{"location":"manual/single_observation/#ObservationSchemes.ν","page":"A single observation","title":"ObservationSchemes.ν","text":"ν(o::Observation)\n\nReturn the observation\n\n\n\n\n\n","category":"function"},{"location":"manual/single_observation/#ObservationSchemes.obs","page":"A single observation","title":"ObservationSchemes.obs","text":"obs(o::Observation)\n\nAlias to ν. Return the observation.\n\n\n\n\n\n","category":"function"},{"location":"manual/single_observation/#Non-linear,-non-Gaussian-observations-1","page":"A single observation","title":"Non-linear, non-Gaussian observations","text":"","category":"section"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"In principle, any observation types are supported, but this comes at a cost of having to provide some information explicitly. The main struct for specifing general observation schemes is","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"ObservationSchemes.GeneralObs","category":"page"},{"location":"manual/single_observation/#ObservationSchemes.GeneralObs","page":"A single observation","title":"ObservationSchemes.GeneralObs","text":"struct GeneralObs{Tag,D,T,FPT,K,Tlo,Tg,Td} <: Observation{D,T}\n    lin_obs::Tlo\n    g::Tg\n    dist::Td\n    obs::T\n    t::Float64\n    θ::Vector{K}\nend\n\nGeneral observation of the underlying process that is of the form: g(x)+ξ, where ξ is distributed according to dist, g is a function specified externally, obs is the observation made at time t, θ is a container that may contain parameters and lin_obs is the approximation to this general observation scheme via the linearization with Gaussian noise.\n\n\n\n\n\n","category":"type"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"For this struct, the required parameters are the time of observation and the observation itself as well as the approximation via LinearGsnObs. For instance, to specify the following observational scheme:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"V_t = g(X_t)+ξ","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"where ξ is distributed according to a bivariate T-distribution with 4 degrees of freedom, some specified mean mu and covariance Sigma, g is a non-linear function:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"g(x)=\nleft(\nbeginmatrix\n(x^1)^2\n(x^2)^2\nendmatrix\nright)","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"we may write:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"using Distributions\n# recording\nt, v = 1.5, [1.0, 2.0]\n\n# for the observation scheme\nμ, Σ = [-1.0, 2.0], [1.0 0.0; 0.0 1.0]\ndist = MvTDist(4, μ, Σ)\ng(x) = view(x, 1:2).^2\n\n# for some poor, ad-hoc Gaussian approximation\nL = [2.0 0.0 0.0; 0.0 2.0 0.0]\n\n# define observation\nobs = GeneralObs(t, v, LinearGsnObs(t, v; L=L, Σ=Σ, μ=μ); dist=dist, g=g)","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"We can now view the summary:","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"julia> summary(obs)\n⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤⏤\n|Observation `v = g(x)+ξ`, where `g` is an operator defined by a function typeof(g), and `ξ` is a random variable given byDistributions.GenericMvTDist{Float64,PDMats.PDMat{Float64,Array{Float64,2}},Array{Float64,1}}.\n|...\n|| ν: [1.0, 2.0, 3.0] (observation),\n||  → typeof(ν): SArray{Tuple{3},Float64,1,3},\n|| made at time 2.0.\n|...\n|This is NOT an exact observation.\n|...\n|It does not depend on any additional parameters.\n|...\n|No first passage times recorded.\n|...\n|To inspect the linearized approximation to this observation scheme please type in:\n|   summary(<name-of-the-variable>.lin_obs)\n|and hit ENTER.\n⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆ ⋆","category":"page"},{"location":"manual/single_observation/#","page":"A single observation","title":"A single observation","text":"tip: Tip\nThe GeneralObs can be decorated with first-passage time information and parameters in the same way as LinearGsnObs can. However, by design, you cannot set full_obs to true for GeneralObs.","category":"page"},{"location":"how_to_guides/simple_os/#simple_observation_schemes-1","page":"(TODO) Efficiently deal with simple observation schemes","title":"Efficiently deal with simple observation schemes","text":"","category":"section"},{"location":"manual/multiple_observations/#Multiple-observations-1","page":"Multiple observations","title":"Multiple observations","text":"","category":"section"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"In practice, we gather multiple observations of a single trajectory of a stochastic process. In this package, we refer to multiple discrete-time observations of a single trajectory as a single recording. We do not enforce any structure on a single recording and instead use a convention of using an appropriate NamedTuple. However, when combining multiple recordings into a single data object AllObservations it is expected that each recording follows the said convention.","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"Below we describe how to handle observations of","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"a single recording\nmultiple recordings from the same law\nmultiple recordings from multiple laws","category":"page"},{"location":"manual/multiple_observations/#Defining-a-single-recording-1","page":"Multiple observations","title":"Defining a single recording","text":"","category":"section"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"To fully describe a single recording we need four elements:","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"The law of the underlying stochastic process\nA starting time\nA prior over the starting point\nDiscrete-time observations of the process","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"Consequently, this package adopts the convention of defining a single recording with a NamedTuple:","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"recording = (\n    P = ...,\n    obs = ...,\n    t0 = ...,\n    x0_prior = ...,\n)","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"The law P needs to be defined by the user.","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"tip: Tip\nTo define diffusion laws you may use DiffusionDefinition.jl. To define conditioned diffusion laws you may use GuidedProposals.jl.","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"warning: Warning\nThere must exist an implementation of a function var_parameter_names(::typeof(P)) if one wants to use functions and structs presented below.","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"obs is assumed to be a vector of observations, with each element being of the type inheriting from Observation{D,T}. x0_prior is assumed to inherit from StartingPtPrior{T}.","category":"page"},{"location":"manual/multiple_observations/#Defining-multiple-recordings-1","page":"Multiple observations","title":"Defining multiple recordings","text":"","category":"section"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"A struct AllObservations allows for a systematic definition of multiple recordings and, in addition, provides some handy functionality.","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"ObservationSchemes.AllObservations","category":"page"},{"location":"manual/multiple_observations/#ObservationSchemes.AllObservations","page":"Multiple observations","title":"ObservationSchemes.AllObservations","text":"struct AllObservations\n    recordings::Vector{Any}\n    param_depend::Dict{Symbol,Vector{Pair{Int64, Symbol}}}\n    obs_depend::Dict{Symbol,Vector{Tuple{Int64,Int64,Int64}}}\n    param_depend_rev::Vector{Vector{Tuple{Symbol,Symbol}}}\n    obs_depend_rev::Vector{Vector{Vector{Tuple{Symbol,Int64}}}}\nend\n\nA struct gathering multiple observations of a diffusion processes. Additionaly, the interdependence structure between parameters shared between various diffusions laws used to generate the recorded data is kept. recordings collects all recordings, param_depend is a dictionary with keys—parameter labels—and values—vectors with entries that list which laws depend on a corresponding parameter. obs_depend does the same but for observations. param_depend_rev gives for each law a list of (variable) parameters it depends on and obs_depend_rev does the same but for the observations.\n\nAllObservations(;P=nothing, obs=nothing, t0=nothing, x0_prior=nothing)\n\nDefault constructor creating either an empty AllObservations object, or initiating it immediately with a single recording where the target comes from the law P, the observations are stored in obs and the observed process was started at time t0 from som position which we put a prior on x0_prior.\n\nAllObservations(recording::NamedTuple)\n\nConstructor creating an AllObservations object and initiating it immediately with a single recording where the target comes from the law recording.P, the observations are stored in recording.obs and the starting point is at time recording.t0 and has a prior x0_prior.\n\n\n\n\n\n","category":"type"},{"location":"manual/multiple_observations/#Recordings-under-a-single,-shared-law-1","page":"Multiple observations","title":"Recordings under a single, shared law","text":"","category":"section"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"We can define multiple recordings as follows:","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"const OBS = ObservationSchemes\nstruct LawA α; β; end\nOBS.var_parameter_names(P::LawA) = [:α, :β]\n\nrecordings = [\n    (\n        P = LawA(10,20),\n        obs = [\n            LinearGsnObs(1.0, 1.0; Σ=1.0),\n            LinearGsnObs(2.0, 2.0; full_obs=true),\n            LinearGsnObs(3.0, 3.0; Σ=2.0),\n        ],\n        t0 = 0.0,\n        x0_prior = KnownStartingPt(2.0),\n    ),\n    (\n        P = LawA(10,20),\n        obs = [\n            LinearGsnObs(1.3, 1.0; full_obs=true),\n            LinearGsnObs(2.3, 2.0; full_obs=true),\n            LinearGsnObs(3.3, 3.0; full_obs=true),\n        ],\n        t0 = 0.3,\n        x0_prior = KnownStartingPt(-2.0),\n    ),\n]\n\nall_obs = AllObservations()\nfor recording in recordings\n    add_recording!(all_obs, recording)\nend","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"note: Note\nIn here we defined the vector recordings verbatim, however we provide an ObsScheme struct together with @load_data macro to do this in an automatic and concise way for many observations at once (see the following section).","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"Observations can be accessed via all_obs.recordings. By default the laws from different recordings are assumed to be independent, but we can tell AllObservations object that they are the same by indicating that the laws share some subsets (possibly all) parameters. This can be done by passing an appropriate dictionary to a function add_dependency:","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"ObservationSchemes.add_dependency!","category":"page"},{"location":"manual/multiple_observations/#ObservationSchemes.add_dependency!","page":"Multiple observations","title":"ObservationSchemes.add_dependency!","text":"add_dependency!(all_obs::AllObservations, dep::Dict)\n\nAdd a dependency structure dep between parameters shared across various laws and observations used to generate various recordings stored in an observations container all_obs.\n\n\n\n\n\n","category":"function"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"add_dependency!(\n    all_obs,\n    Dict(\n        :α_shared => [(1, :α), (2, :α)],\n        :β_shared => [(1, :β), (2, :β)],\n    )\n)","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"The first (respectively second) entry in the dictionary tells all_obs that there is a parameter, which from now on will be labeled :α_shared (resp. :β_shared), that is present in the law of recording 1 and the law of recording 2 and in both of these cases if one calls var_parameter_names(P) then the referred to parameter should have a name :α (resp. :β).","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"note: Note\nIf the parameter appears in the observation instead of the law, then the previous tuple of the format (rec_idx, :param-name) must be substituted with: (rec_idx, obs_idx, param_idx_in_obs_vec), for instance:add_dependency!(\n    all_obs,\n    Dict(\n        :γ_shared => [(1, 2, 3), (40, 400, 4)],\n    )\n)indicates that there is a shared parameter :γ_shared that enters the second observations in a first recording and that it is the third parameter of this observation and that it also enters 400th observation of the 40th recording and that it enters the 4th parameter of that observation.","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"Now, we can additionally call","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"ObservationSchemes.initialize","category":"page"},{"location":"manual/multiple_observations/#ObservationSchemes.initialize","page":"Multiple observations","title":"ObservationSchemes.initialize","text":"initialize(all_obs::AllObservations)\n\nSplit the recordings at the times of full observations to make full use of the Markov property (and make the code readily parallelisable). Introduce all parameters that were not mentioned in the current dependency dictionary. Create dictionaries that allow for efficient retreival of all laws and observations that depend on any specified parameter\n\n\n\n\n\n","category":"function"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"as in:","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"initialised_all_obs, old_to_new_idx = initialize(all_obs)","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"to perform three useful operations.","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"First, all parameters that are not shared between various laws will be marked (here, there is no such parameter, so this step does not do anything, see example below which illustrates this idea),\nSecond, the recordings are split at the times at which full observations are made, as full observations allows for employment of Markov property and treatment of the problem in parallel. As a result, initialised_all_obs now has 5 recordings, all coming from the same law LawA.\nThird, an additional dependence structure is introduced that allows for efficient retrieval of information about parameter dependence when iterating through laws and observations.","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"tip: Tip\nThe old_to_new_idx might be helpful for keeping track of the original indices of recordings.","category":"page"},{"location":"manual/multiple_observations/#Recordings-under-multiple-laws-1","page":"Multiple observations","title":"Recordings under multiple laws","text":"","category":"section"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"It should be clear that the formalism above allows for definition of recordings coming from multiple diffusion laws. For instance, we can have","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"struct LawB γ; β; end\nOBS.var_parameter_names(P::LawB) = [:γ, :β]\n\nextra_recording = (\n    P = LawB(30,40),\n    obs = [\n        LinearGsnObs(1.5, 1.0; Σ=1.0),\n        LinearGsnObs(2.5, 2.0; Σ=1.0),\n    ],\n    t0 = 0.5,\n    x0_prior = KnownStartingPt(10.0),\n)\npush!(recordings, extra_recording)\n\nall_obs = AllObservations()\nfor recording in recordings\n    add_recording!(all_obs, recording)\nend","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"The dictionary specifying interdependence between the laws of stochastic processes can now be defined as follows:","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"add_dependency!(\n    all_obs,\n    Dict(\n        :α_shared => [(1, :α), (2, :α)],\n        :β_shared => [(1, :β), (2, :β), (3,:β)],\n    )\n)","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"where, notice presence of additional (3,:β). This time, calling","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"initialised_all_obs, _ = initialize(all_obs)","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"not only splits the recordings at the time of full observations (resulting in 6 independent recordings), but also introduces a new named parameter REC3_γ that only the last recording depends on. This comes from the fact that in the original all_obs the third recording came from law LawB, which depends on a parameter γ that was not shared with any other recording and hence did not appear in the inter-dependency dictionary. Every such \"lonely\" parameter is introduced by a function initialize and is given a name by pre-pending its original name with REC($i)_, with ($i) denoting the original index of a recording that the parameter came from.","category":"page"},{"location":"manual/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"warning: Warning\nIntroducing parameterized observations and indicating their positions is not yet fully supported","category":"page"},{"location":"how_to_guides/custom_priors/#how_to_custom_prior-1","page":"(TODO) Define custom priors over starting points","title":"How to define custom priors over starting points?","text":"","category":"section"},{"location":"manual/start_pt_prior/#Priors-over-starting-points-1","page":"Priors over starting points","title":"Priors over starting points","text":"","category":"section"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"On top of decorating each observation with appropriate information, for stochastic processes we need to provide additional information that describes the starting position of the process (as, for instance, no observation may be made at the initial time). This is done through prior distributions.","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"All priors over starting points inherit from","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"ObservationSchemes.StartingPtPrior","category":"page"},{"location":"manual/start_pt_prior/#ObservationSchemes.StartingPtPrior","page":"Priors over starting points","title":"ObservationSchemes.StartingPtPrior","text":"StartingPtPrior\n\nTypes inheriting from the abstract type StartingPtPrior indicate the prior that is put on the starting point of the observed path of some stochastic process\n\n\n\n\n\n","category":"type"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"They all must implement methods rand, start_pt, and logpdf (and should also implement inv_start_pt for MCMC setting). In this package we provide implementations for the following types of starting points","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"Known, fixed starting points\nGaussian priors over starting points","category":"page"},{"location":"manual/start_pt_prior/#Known-starting-point-1","page":"Priors over starting points","title":"Known starting point","text":"","category":"section"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"This is the simplest setting in which the starting point is assumed to be known.","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"ObservationSchemes.KnownStartingPt","category":"page"},{"location":"manual/start_pt_prior/#ObservationSchemes.KnownStartingPt","page":"Priors over starting points","title":"ObservationSchemes.KnownStartingPt","text":"struct KnownStartingPt{T} <: StartingPtPrior{T}\n    y::T\nend\n\nIndicates that the starting point is known and stores its value in y\n\n\n\n\n\n","category":"type"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"It can be defined with","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"x0 = [1.0, 2.0]\nx0_prior = KnownStartingPt(x0)","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"a call to rand or start_pt will simply return the fixed starting point and logpdf(x0_prior, y) evaluates to 0 so long as x0 == y.","category":"page"},{"location":"manual/start_pt_prior/#Gaussian-priors-1","page":"Priors over starting points","title":"Gaussian priors","text":"","category":"section"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"A Gaussian prior over the starting point.","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"ObservationSchemes.GsnStartingPt","category":"page"},{"location":"manual/start_pt_prior/#ObservationSchemes.GsnStartingPt","page":"Priors over starting points","title":"ObservationSchemes.GsnStartingPt","text":"struct GsnStartingPt{T,S,TM} <: StartingPtPrior{T} where {S}\n    μ::T\n    Σ::S\n    Λ::S\n    μ₀::T\n    Σ₀::UniformScaling\nend\n\nIndicates that the starting point is equipped with a Gaussian prior with mean μ and covariance matrix Σ (and pre-computed precision Λ:=Σ⁻¹). Sampling is always done via non-centred parametrization, by sampling white noise z according to Gaussian with zero mean and identity covariance: μ₀ and Σ₀, and then transforming z to a variable with mean and covariance μ and Σ.\n\n\n\n\n\n","category":"type"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"Can be defined with","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"μ, Σ = [1.0, 2.0], [1.0 0.0; 0.0 1.0]\nx0_prior = GsnStartingPt(μ, Σ)","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"to set the mean and covariance to μ and Σ respectively. The underlying idea behind Gaussian starting point priors is that of non-centred parametrisation, so that a possibility of local updates is granted. More precisely any sampling is done with z∼N(0,Id) variables, which are then transformed to N(μ,Σ) via linear transformations. In particular, sampling with rand can be done with local perturbations via Crank-Nicolson scheme.","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"ObservationSchemes.rand","category":"page"},{"location":"manual/start_pt_prior/#Base.rand","page":"Priors over starting points","title":"Base.rand","text":"rand([rng::Random.AbstractRNG], G::GsnStartingPt, z, ρ=0.0)\n\nSample new white noise using Crank-Nicolson scheme with memory parameter ρ and a previous value of the white noise stored inside object G\n\n\n\n\n\nrand([rng::Random.AbstractRNG], G::GsnStartingPt)\n\nSample new starting point according to its prior distribution.\n\n\n\n\n\nrand([rng::Random.AbstractRNG], G::KnownStartingPt, args...)\n\nStarting point is known. Nothing can be sampled. Returning known starting point.\n\n\n\n\n\n","category":"function"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"inv_start_pt returns the non-centrally parametrised noise z that produces a given starting point x0:","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"ObservationSchemes.inv_start_pt","category":"page"},{"location":"manual/start_pt_prior/#ObservationSchemes.inv_start_pt","page":"Priors over starting points","title":"ObservationSchemes.inv_start_pt","text":"inv_start_pt(y, G::GsnStartingPt, P)\n\nCompute the driving noise that is needed to obtain starting point y under prior G and the likelihood in P\n\n\n\n\n\ninv_start_pt(y, G::KnownStartingPt, P)\n\nStarting point known, no need for dealing with white noise, use convention of returning y\n\n\n\n\n\n","category":"function"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"and start_pt is the reverse operation","category":"page"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"ObservationSchemes.start_pt","category":"page"},{"location":"manual/start_pt_prior/#ObservationSchemes.start_pt","page":"Priors over starting points","title":"ObservationSchemes.start_pt","text":"start_pt(z, G::GsnStartingPt, P)\n\nCompute a new starting point from the white noise for a given posterior distribution obtained from combining prior G and the likelihood encoded by the object P.\n\n\n\n\n\nstart_pt(z, G::GsnStartingPt)\n\nCompute a new starting point from the white noise for a given prior distribution G\n\n\n\n\n\nstart_pt(z, G::KnownStartingPt, P)\n\nReturn starting point\n\n\n\n\n\nstart_pt(G::KnownStartingPt, P)\n\nReturn starting point\n\n\n\n\n\n","category":"function"},{"location":"manual/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"tip: Tip\nTo see how to define your own priors over starting points see a How-to-guide on Defining custom priors over starting points","category":"page"},{"location":"manual/utility_functions/#Utility-functions-1","page":"Utility fuctions","title":"Utility functions","text":"","category":"section"},{"location":"manual/utility_functions/#","page":"Utility fuctions","title":"Utility fuctions","text":"We provide some additional utility functions.","category":"page"},{"location":"manual/utility_functions/#","page":"Utility fuctions","title":"Utility fuctions","text":"Modules = [ObservationSchemes]\nPages   = [\"convenience_functions.jl\"]","category":"page"},{"location":"manual/utility_functions/#ObservationSchemes.build_recording-Union{Tuple{K}, Tuple{Type{K},Any,Array{T,1} where T,Any,Any,Any}} where K","page":"Utility fuctions","title":"ObservationSchemes.build_recording","text":"build_recording(\n        ::Type{K}, tt, observs::Vector, P, t0, x0_prior; kwargs...\n    ) where K\n\nUtility function to build a recording that follows the convention adopted in package ObservationSchemes.\n\n\n\n\n\n","category":"method"},{"location":"manual/utility_functions/#ObservationSchemes.num_obs-Tuple{AllObservations}","page":"Utility fuctions","title":"ObservationSchemes.num_obs","text":"num_obs(all_obs::AllObservations)\n\nReturn total number of observations\n\n\n\n\n\n","category":"method"},{"location":"manual/utility_functions/#ObservationSchemes.num_recordings-Tuple{AllObservations}","page":"Utility fuctions","title":"ObservationSchemes.num_recordings","text":"num_recordings(all_obs::AllObservations)\n\nReturn total number of recordings\n\n\n\n\n\n","category":"method"},{"location":"manual/utility_functions/#ObservationSchemes.package","page":"Utility fuctions","title":"ObservationSchemes.package","text":"package\n\nVarious packaging functions that zip together objects/functions/structs together with observations defined in AllObservations/recording\n\n\n\n\n\n","category":"function"},{"location":"manual/utility_functions/#ObservationSchemes.setup_time_grids","page":"Utility fuctions","title":"ObservationSchemes.setup_time_grids","text":"setup_time_grids(\n    all_obs::AllObservations,\n    dt=0.01,\n    τ=identity,\n    eltype=Float64,\n    already_arranged_tt=nothing\n)\n\nSame as a version for a single recording, but applies recursively  to all recordings in all_obs.\n\n\n\n\n\n","category":"function"},{"location":"manual/utility_functions/#ObservationSchemes.setup_time_grids","page":"Utility fuctions","title":"ObservationSchemes.setup_time_grids","text":"setup_time_grids(\n    recording::NamedTuple,\n    dt=0.01,\n    τ=identity,\n    eltype=Float64,\n    already_arranged_tt=nothing\n)\n\nSet up a time grid for a single recording. Starts with an equidistant time grid with mesh witdh dt and applies a transformation τ to each inter-observation integral. Alternatively, if already_arranged_tt is passed then the initial setting up of equidistant grid is omitted and already_arrange_tt is used in its place for the τ transformation.\n\n\n\n\n\n","category":"function"},{"location":"manual/utility_functions/#ObservationSchemes.setup_time_grids","page":"Utility fuctions","title":"ObservationSchemes.setup_time_grids","text":"setup_time_grids(\n    t0::Number,\n    T::Number,\n    dt=0.01,\n    τ=identity,\n    eltype=Float64,\n    already_arranged_tt=nothing\n)\n\nSet up a time grid for a single inter-observation interval [t0, T]. Starts with an equidistant time grid with mesh witdh dt and applies a transformation τ afterwards. Alternatively, if already_arranged_tt is passed then the initial setting up of an equidistant grid is omitted and already_arrange_tt is used in its place for the τ transformation.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/single_path/#tutorial_single_path-1","page":"(TODO) Single path","title":"Define observation scheme for a single path","text":"","category":"section"},{"location":"manual/observation_schemes/#obs_scheme-1","page":"Observation schemes","title":"Defining observation schemes and loading data","text":"","category":"section"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"","category":"page"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"Most often we collect multiple data points from a single observation scheme. Decorating each and single one of the observations as in the previous section might become quite tiring. To this end we provide a struct ObsScheme together with a function load_data for a convenient way of decorating multiple observations at once.","category":"page"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"ObservationSchemes.ObsScheme\nObservationSchemes.load_data","category":"page"},{"location":"manual/observation_schemes/#ObservationSchemes.ObsScheme","page":"Observation schemes","title":"ObservationSchemes.ObsScheme","text":"struct ObsScheme{T}\n    obs::T\n    pattern::Vector{Int64}\n    full_pattern::Vector{Int64}\n    mode::Val\nend\n\nDefines an observation scheme for convenient loading of multiple data points at once and automatically equipping them with observation decorators stored in obs recycling through a set of indeces specified in pattern that pick the order of observation templates in obs that need to be applied.\n\n\n\n\n\n","category":"type"},{"location":"manual/observation_schemes/#ObservationSchemes.load_data","page":"Observation schemes","title":"ObservationSchemes.load_data","text":"load_data(os::ObsScheme, tt, xx)\n\nDecorate the data in xx and times of recordings in tt according to an observation scheme template stored in os.\n\n\n\n\n\nload_data(os::ObsScheme, tt_xx)\n\nSame as load_data(os::ObsScheme, tt, xx), but tt_xx is a vector of tuples that pair the observation with its recorded time.\n\n\n\n\n\n","category":"function"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"For instance, if all data is collected according to a single observation scheme:","category":"page"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"t, v = 1.0, [1.0, 2.0, 3.0] # dummy values, only DataType matter\nobs = LinearGsnObs(t, v; full_obs=true)","category":"page"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"Then we can define it as an observation scheme and load the data as follows:","category":"page"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"tt = [1.0, 2.0, 3.0, 4.0, 5.0]\nxx = [i.+rand(3) for i in eachindex(tt)]\n\ndata = load_data(ObsScheme(obs), tt, xx)","category":"page"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"If more than one type of observation schemes are used then we can specify a list of them to ObsScheme and then specify the pattern in which we cycle through them when loading the data:","category":"page"},{"location":"manual/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"# another observation scheme:\nt, v = 1.0, SVector{2,Float64}(1.0, 2.0)\nobs2 = LinearGsnObs(t, v; full_obs=true)\n\n# observations:\nxx = [i%2==1 ? i.+rand(3) : i.+rand(SVector{2,Float64}) for i in eachindex(tt)]\n\n# load the data:\ndata = load_data(ObsScheme(obs, obs2; pattern=[1,2]), tt, xx)","category":"page"},{"location":"#ObservationSchemes.jl-1","page":"Home","title":"ObservationSchemes.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This is a utility package belonging to a suite of packages DiffusionBayes.jl. Its purpose is to provide a systematic way of encoding discrete-time observations for stochastic processes.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The underlying idea behind the package is to provide a set of decorators that may be used to equip each data-point separately, and in doing so, describe how a given data-point has been recorded. This flexible framework can be used to define complex observation schemes in a simple way.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The following types of observations can be defined with this package:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Exact observations of all or a subset of all coordinates of the underlying process\nLinear translations of the underlying process, disturbed by Gaussian noise (or non-Gaussian noise)\nFirst-passage time observations\nFirst-passage time observations with additional resetting events\nNon-linear observations with Gaussian or non-Gaussian noise\nParameterized versions of all observation types above","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Additionally, the package provides functionality to couple multiple observations together, so as to define:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Multiple observations of a single process\nMultiple observations of multiple processes, coming possibly from different laws that share subsets of parameters (mixed-effect models)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Finally, we provide infrastructure for defining priors over starting points. In particular we add concrete implementations of","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Degenerate priors corresponding to fixed starting points\nGaussian priors","category":"page"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Depending on your intended use of this package you might choose to start at different places:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For a quick overview of ObservationSchemes.jl's main functionality see Get started\nFor a systematic introduction to all functionality introduced in this package see the Manual\nFor a didactic introduction to problems that can be solved using ObservationSchemes.jl see the Tutorials\nIf you have a problem that you think can be addressed with this package, then check out the How-to guides to see if the answer is already there.","category":"page"}]
}
