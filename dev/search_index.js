var documenterSearchIndex = {"docs":
[{"location":"module_index/#ObservationSchemes.jl-1","page":"Index","title":"ObservationSchemes.jl","text":"","category":"section"},{"location":"module_index/#","page":"Index","title":"Index","text":"","category":"page"},{"location":"module_index/#","page":"Index","title":"Index","text":"Modules = [ObservationSchemes]","category":"page"},{"location":"module_index/#ObservationSchemes.AllObservations","page":"Index","title":"ObservationSchemes.AllObservations","text":"AllObservations\n\nA struct gathering multiple observations of a diffusion processes. Additionaly, the interdependence structure between parameters shared between various diffusions laws used to generate the recorded data is kept.\n\n    AllObservations(;P=nothing, obs=nothing)\n\nDefault constructor creating either an empty `AllObservations` object,\nor initiates it immediately with a single recording where the target comes\nfrom the law `P`, the observations are stored in `obs` and the observed\nprocess was started at time `t0` from som position which we put a prior on\n`x0_prior`.\n\n    AllObservations(recording::NamedTuple)\n\nConstructor creating an `AllObservations` object and initiating it\nimmediately with a single recording where the target comes\nfrom the law `recording.P`, the observations are stored in `recording.obs`\nand the starting point is at time `recording.t0` and has a prior `x0_prior`.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ObservationSchemes.FirstPassageTimeInfo","page":"Index","title":"ObservationSchemes.FirstPassageTimeInfo","text":"FirstPassageTimeInfo{C,L,U,A} <: FirstPassageAbstract\n\nCompile-time indicator for the first-passage time information conveyed by the data-point. C lists the affected coordinates (of the observations, not the process), L indicates the level, U are indicators for whether the respective first-passage times are up-crossings and A is and indicator for whether an additional reset needs to be reached before first-passage time (note that reset time is defined as a first-passage time to a corresponding reset level stored in R that happens anytime before the actual first-passage time, the reset-time happens in the direction opposite to the direction of first-passage time crossing; additionally, the coordinate can reach the first-passage time level prior to being reset).\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ObservationSchemes.GsnStartingPt","page":"Index","title":"ObservationSchemes.GsnStartingPt","text":"GsnStartingPt{T,S} <: StartingPtPrior\n\nIndicates that the starting point is equipped with a Gaussian prior with mean μ and covariance matrix Σ. It also stores the most recently sampled white noise z used to compute the starting point and a precision matrix Λ:=Σ⁻¹. μ₀ and Σ₀ are the mean and covariance of the white noise\n\nGsnStartingPt(μ::T, Σ::S)\n\nBase constructor. It initialises the mean μ and covariance Σ parameters and Λ is set according to Λ:=Σ⁻¹\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ObservationSchemes.KnownStartingPt","page":"Index","title":"ObservationSchemes.KnownStartingPt","text":"KnownStartingPt{T} <: StartingPtPrior\n\nIndicates that the starting point is known and stores its value in y\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ObservationSchemes.LinearGsnObs","page":"Index","title":"ObservationSchemes.LinearGsnObs","text":"LinearGsnObs{D,T,FPT,S,R} <: Observation{D,T}\n\nObservation of the underlying process that is of the form: LX+ξ, where ξ∼N(μ,Σ) and L,Σ and μ are respectively matrices and a vector of appropriate dimensions. FPT stores information about first-passage times. full_obs is an indicator for whether it is a full observation of the process (as it grants the use of Markov Property)\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ObservationSchemes.NoFirstPassageTimes","page":"Index","title":"ObservationSchemes.NoFirstPassageTimes","text":"NoFirstPassageTimes <: FirstPassageAbstract\n\nCompile-time indicator that the observation stores no first-passage time data\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ObservationSchemes.add_dependency!-Tuple{AllObservations,Dict}","page":"Index","title":"ObservationSchemes.add_dependency!","text":"add_dependency!(all_obs::AllObservations, dep::Dict)\n\nAdd a dependency structure dep between parameters shared across various laws and observations used to generate various recordings stored in an observations container all_obs.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.add_recording!-Tuple{AllObservations,NamedTuple}","page":"Index","title":"ObservationSchemes.add_recording!","text":"add_recording!(all_obs::AllObservations, recording::NamedTuple)\n\nAdd a new recording recording to observations container all_obs.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.fpt_info-Union{Tuple{LinearGsnObs{D,T,FPT,S,R} where R where S}, Tuple{FPT}, Tuple{T}, Tuple{D}} where FPT where T where D","page":"Index","title":"ObservationSchemes.fpt_info","text":"fpt_info(::LinearGsnObs{D,T,FPT}) where {D,T,FPT}\n\nReturn information about first-passage times\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.initialize!-Tuple{AllObservations}","page":"Index","title":"ObservationSchemes.initialize!","text":"initialize(all_obs::AllObservations)\n\nSplit the recordings at the times of full observations to make full use of the Markov property (and make the code readily parallelisable).\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.FirstPassageAbstract","page":"Index","title":"ObservationSchemes.FirstPassageAbstract","text":"FirstPassageAbstract\n\nTypes ihneriting from this struct define the type of information stored about first-passage times\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ObservationSchemes.Observation","page":"Index","title":"ObservationSchemes.Observation","text":"Observation{D,T}\n\nTypes inheriting from this struct provide all information about the observation of the stochastic process being made. D denotes the dimension of the observation whereas T its datatype.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ObservationSchemes.StartingPtPrior","page":"Index","title":"ObservationSchemes.StartingPtPrior","text":"StartingPtPrior\n\nTypes inheriting from the abstract type StartingPtPrior indicate the prior that is put on the starting point of the observed path following the dynamics of some stochastic differential equation.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#Base.rand","page":"Index","title":"Base.rand","text":"rand(G::KnownStartingPt, ::Any)\n\nIf starting point is known then nothing can be sampled, using convention of returning the known startin point\n\n\n\n\n\n","category":"function"},{"location":"module_index/#Base.rand-Tuple{GsnStartingPt}","page":"Index","title":"Base.rand","text":"rand(G::GsnStartingPt, ρ)\n\nSample new white noise using Crank-Nicolson scheme with memory parameter ρ and a previous value of the white noise stored inside object G\n\n\n\n\n\n","category":"method"},{"location":"module_index/#Distributions.logpdf-Tuple{GsnStartingPt,Any}","page":"Index","title":"Distributions.logpdf","text":"logpdf(::GsnStartingPt, y)\n\nlog-probability density function evaluated at y of a prior distribution G\n\n\n\n\n\n","category":"method"},{"location":"module_index/#Distributions.logpdf-Tuple{KnownStartingPt,Any}","page":"Index","title":"Distributions.logpdf","text":"logpdf(::KnownStartingPt, y)\n\nNothing to do so long as y is equal to the known starting point inside G\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.check_recording_format-Union{Tuple{T}, Tuple{T}} where T<:NamedTuple","page":"Index","title":"ObservationSchemes.check_recording_format","text":"check_recording_format(::T) where T<:NamedTuple\n\nCheck whether the namedtuple has fields P, obs, t0 and x0_prior that each recording must have.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.fill_dependency_for_unspec_params!-Tuple{AllObservations}","page":"Index","title":"ObservationSchemes.fill_dependency_for_unspec_params!","text":"fill_dependency_for_unspec_params!(all_obs::AllObservations)\n\nFill the all_obs.depen_param dictionary with all parameters that are not shared between recordings.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.format_dep_entry-Tuple{Val{true},Any,Any}","page":"Index","title":"ObservationSchemes.format_dep_entry","text":"format_dep_entry(P, entry)\n\nFormat an entry pointing to a specific parameter in a specific law used for a specific recording so that it encodes recording index rec_idx, parameter index param_idx and parameter name param_name of the pointing to position.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.format_law_dep_entry-Tuple{Any,Tuple{Int64,Bool,Int64,Symbol}}","page":"Index","title":"ObservationSchemes.format_law_dep_entry","text":"format_dep_entry(P, entry::Tuple{Int64,Int64,Symbol})\n\nMake sure that recording index rec_idx, parameter index param_idx and parameter name param_name make sense and are formatted correctly.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.format_law_dep_entry-Tuple{Any,Tuple{Int64,Bool,Int64}}","page":"Index","title":"ObservationSchemes.format_law_dep_entry","text":"format_dep_entry(P, entry::Tuple{Int64,Int64})\n\nInfer recording index rec_idx, parameter index param_idx and parameter name param_name from the pair that lists recording index and parameter index within the law that was used for that recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.format_law_dep_entry-Tuple{Any,Tuple{Int64,Bool,Symbol}}","page":"Index","title":"ObservationSchemes.format_law_dep_entry","text":"format_dep_entry(P, entry::Tuple{Int64,Symbol})\n\nInfer recording index rec_idx, parameter index param_idx and parameter name param_name from the pair that lists recording index and parameter name within the law that was used for that recording.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.inv_start_pt-Tuple{Any,GsnStartingPt,Any}","page":"Index","title":"ObservationSchemes.inv_start_pt","text":"inv_start_pt(y, G::GsnStartingPt, P)\n\nCompute the driving noise that is needed to obtain starting point y under prior G and the likelihood in P\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.inv_start_pt-Tuple{Any,KnownStartingPt,Any}","page":"Index","title":"ObservationSchemes.inv_start_pt","text":"inv_start_pt(y, G::KnownStartingPt, P)\n\nStarting point known, no need for dealing with white noise, use convention of returning y\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.new_param_dependence!-NTuple{4,Any}","page":"Index","title":"ObservationSchemes.new_param_dependence!","text":"new_param_dependence!(out, old_dep, old_to_new_idx)\n\nDefine a new parameter dependence structure by using an old parameter dependence saved in old_dep and deducing the changed indices of affected recording by following the old_to_new_idx dictionary. The new dependency is saved directly to out structure.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.parameter_names","page":"Index","title":"ObservationSchemes.parameter_names","text":"parameter_names\n\nReturn names of the parameters of a given object\n\n\n\n\n\n","category":"function"},{"location":"module_index/#ObservationSchemes.split_recording!-Tuple{Any,Any,Any,AllObservations,Any,Any}","page":"Index","title":"ObservationSchemes.split_recording!","text":"split_recording!(\n        recording_idx,\n        recording,\n        counter,\n        out::AllObservations,\n        old_to_new_idx,\n        old_to_new_obs_idx,\n    )\n\nSplit a single record recording at the times of full observations. Save new, splitted recordings in the struct out. Keep account of the changed indices of the recordings for the recording index <---> parameter dependence pairs by updating a suitable dictionary old_to_new_idx, starting the new recording's index at an offset counter.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.start_pt-Tuple{Any,GsnStartingPt,Any}","page":"Index","title":"ObservationSchemes.start_pt","text":"start_pt(G::GsnStartingPt, P)\n\nCompute a new starting point from the white noise for a given posterior distribution obtained from combining prior G and the likelihood encoded by the object P.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.start_pt-Tuple{Any,GsnStartingPt}","page":"Index","title":"ObservationSchemes.start_pt","text":"start_pt(G::GsnStartingPt, P)\n\nCompute a new starting point from the white noise for a given prior distribution G\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.start_pt-Tuple{Any,KnownStartingPt,Any}","page":"Index","title":"ObservationSchemes.start_pt","text":"start_pt(G::KnownStartingPt, P)\n\nReturn starting point\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ObservationSchemes.start_pt-Tuple{Any,KnownStartingPt}","page":"Index","title":"ObservationSchemes.start_pt","text":"start_pt(G::KnownStartingPt, P)\n\nReturn starting point\n\n\n\n\n\n","category":"method"},{"location":"overview/multiple_observations/#Multiple-observations-1","page":"Multiple observations","title":"Multiple observations","text":"","category":"section"},{"location":"overview/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"Multiple discrete-time observations of a single trajectory are referred to in this package as a single recording. Below we describe how to handle observations of","category":"page"},{"location":"overview/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"a single recording\nmultiple recordings from the same law\nmultiple recordings from multiple laws","category":"page"},{"location":"overview/multiple_observations/#Defining-a-single-recording-1","page":"Multiple observations","title":"Defining a single recording","text":"","category":"section"},{"location":"overview/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"To fully describe a single recording we need four elements:","category":"page"},{"location":"overview/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"A diffusion law that the underlying process is following\nA starting time\nA prior over the starting point\nDiscrete-time observations of the process","category":"page"},{"location":"overview/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"Consequently, this package adopts the convention of defining a single recording with a NamedTuple:","category":"page"},{"location":"overview/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"recording = (\n    P = ...,\n    obs = ...,\n    t0 = ...,\n    x0_prior = ...,\n)","category":"page"},{"location":"overview/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"The law P needs to be defined by the user and a package DiffusionDefinition.jl can be used to this end. There must exist an implementation of a function param_name(::typeof(P)) if one wants to use functions and structs presented below. obs is assumed to be a vector of observations, with each element being of the type inheriting from Observation{D,T}. x0_prior is assumed to inherit from StartingPtPrior{T}.","category":"page"},{"location":"overview/multiple_observations/#Defining-multiple-recordings-1","page":"Multiple observations","title":"Defining multiple recordings","text":"","category":"section"},{"location":"overview/multiple_observations/#Recordings-under-a-single,-shared-law-1","page":"Multiple observations","title":"Recordings under a single, shared law","text":"","category":"section"},{"location":"overview/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"A struct AllObservations allows for a systematic definition of multiple recordings and, in addition, provides some handy functionality. For instance, we can define multiple recordings as follows:","category":"page"},{"location":"overview/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"struct LawA α; β; end\nDiffObservScheme.param_names(P::LawA) = [:α, :β]\n\nrecordings = [\n    (\n        P = LawA(10,20),\n        obs = [\n            LinearGsnObs(1.0, 1.0; Σ=1.0),\n            LinearGsnObs(2.0, 2.0; full_obs=true),\n            LinearGsnObs(3.0, 3.0; Σ=2.0),\n        ],\n        t0 = 0.0,\n        x0_prior = KnownStartingPt(2.0),\n    ),\n    (\n        P = LawA(10,20),\n        obs = [\n            LinearGsnObs(1.3, 1.0; full_obs=true),\n            LinearGsnObs(2.3, 2.0; full_obs=true),\n            LinearGsnObs(3.3, 3.0; full_obs=true),\n        ],\n        t0 = 0.3,\n        x0_prior = KnownStartingPt(-2.0),\n    ),\n]\n\nall_obs = AllObservations()\nfor recording in recordings\n    add_recording!(all_obs, recording)\nend","category":"page"},{"location":"overview/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"Observations can be accessed via all_obs.recordings. By default the laws from different recordings are assumed to be independent, but we can tell AllObservations object that they are the same by indicating that the laws share some subsets (possibly all) parameters. This can be done by passing an appropriate dictionary to function add_dependency:","category":"page"},{"location":"overview/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"add_dependency!(\n    all_obs,\n    Dict(\n        :α_shared => [(rec=1, p_name=:α), (rec=2, p_name=:α)],\n        :β_shared => [(rec=1, p_name=:β), (rec=2, p_name=:β)],\n    )\n)","category":"page"},{"location":"overview/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"The first (respectively second) entry in the dictionary tells all_obs that there is a parameter, which from now on will be labeled :α_shared (resp. :β_shared), that is present in the law of recording 1 and the law of recording 2 and in both of these cases if one calls param_name(P) then the referred to parameter should have a name :α (resp. :β). We can also tell the same thing to AllObservations object differently:","category":"page"},{"location":"overview/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"add_dependency!(\n    all_obs,\n    Dict(\n        :α_shared => [(rec=1, p_idx=1), (rec=2, p_name=:α)],\n        :β_shared => [(rec=1, p_idx=2, p_name=:β), (rec=2, p_idx=2)],\n    )\n)","category":"page"},{"location":"overview/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"where instead of specifying the name via p_name we specify the index which this parameter takes when a call to param_name(P) is made. We can also specify both and then the error will be thrown if two access paths are not pointing to the same parameter. The names of the NamedTuples: (rec=..., p_idx=), (rec=..., p_name=...) and (rec=..., p_idx=..., p_name=...) above don't matter (in fact they are later downgraded to regular tuples), only the order of their entries. Now, we can additionally call:","category":"page"},{"location":"overview/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"initialised_all_obs = initialise!(all_obs)","category":"page"},{"location":"overview/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"to perform two useful operations. First, all parameters that are not shared between various laws will be marked (here, there is no such parameter, so this step does not do anything, see example below which illustrates this idea), second, the recordings are split at the times at which full observations are made, as full observations allows for employment of Markov property and treatment of the problem in parallel. As a result, initialised_all_obs now has 5 recordings, all coming from the same law LawA.","category":"page"},{"location":"overview/multiple_observations/#Recordings-under-multiple-laws-1","page":"Multiple observations","title":"Recordings under multiple laws","text":"","category":"section"},{"location":"overview/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"It should be clear that the formalism above allows for definition of recordings coming from multiple diffusion laws. For instance, we can have","category":"page"},{"location":"overview/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"struct LawB γ; β; end\nDiffObservScheme.param_names(P::LawB) = [:γ, :β]\n\nextra_recording = (\n    P = LawB(30,40),\n    obs = [\n        LinearGsnObs(1.5, 1.0; Σ=1.0),\n        LinearGsnObs(2.5, 2.0; Σ=1.0),\n    ],\n    t0 = 0.5,\n    x0_prior = KnownStartingPt(10.0),\n)\npush!(recordings, extra_recording)\n\nall_obs = AllObservations()\nfor recording in recordings\n    add_recording!(all_obs, recording)\nend","category":"page"},{"location":"overview/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"The dictionary specifying interdependence between diffusion laws can now be defined as follows:","category":"page"},{"location":"overview/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"add_dependency!(\n    all_obs,\n    Dict(\n        :α_shared => [(rec=1, p_name=:α), (rec=2, p_name=:α)],\n        :β_shared => [(rec=1, p_name=:β), (rec=2, p_name=:β), (rec=3, p_name=:β)],\n    )\n)","category":"page"},{"location":"overview/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"where, notice presence of additional (rec=3, p_name=:β). Now, calling","category":"page"},{"location":"overview/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"initialised_all_obs = initialise!(all_obs)","category":"page"},{"location":"overview/multiple_observations/#","page":"Multiple observations","title":"Multiple observations","text":"not only splits the recordings at the time of full observations (resulting in 6 independent recordings), but also introduces a new named parameter REC3_γ that only the last recording depends on. This comes from the fact that in the original all_obs the third recording came from law LawB, which depended on a parameter γ that was not shared with any other recording and hence did not appear in the interdependency dictionary. Every such \"lonely\" parameter is introduced by a function initialise! and is given a name by prepending its original name with REC($i)_, with ($i) denoting the original index of a recording that the parameter came from.","category":"page"},{"location":"overview/observation_schemes/#Observation-schemes-1","page":"Observation schemes","title":"Observation schemes","text":"","category":"section"},{"location":"overview/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"All observation schemes inherit from a struct Observation{D,T} and have methods eltype, size and length implemented for them.","category":"page"},{"location":"overview/observation_schemes/#Linear-Gaussian-struct-1","page":"Observation schemes","title":"Linear Gaussian struct","text":"","category":"section"},{"location":"overview/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"The most important observation scheme (and, currently, the only one that is implemented) is LinearGsnObs. It is suitable for representing observations that can be written in the following format:","category":"page"},{"location":"overview/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"beginequationlabeleqobs_scheme\nV_t = LX_t+xiquad xisim N(μΣ)\nendequation","category":"page"},{"location":"overview/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"where LinRR^dtimes d and X_t is a state of the underlying stochastic process. We describe various special cases of the above scheme below.","category":"page"},{"location":"overview/observation_schemes/#Exact-observations-of-the-process-1","page":"Observation schemes","title":"Exact observations of the process","text":"","category":"section"},{"location":"overview/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"A degenerate case of the above is an exact observation of X_t, i.e. when","category":"page"},{"location":"overview/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"L = I_dqquad μ = 0_dtimes 1qquad Σ = 0_dtimes d","category":"page"},{"location":"overview/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"so that X_t=V_t. This can be defined as:","category":"page"},{"location":"overview/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"v = [1.0, 2.0, 3.0]\nobs = LinearGsnObs(v; full_obs=true)","category":"page"},{"location":"overview/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"by default the covariance matrix of the noise Σ is set to Sigma=10^-11I_d for numerical reasons. This can be changed by specifying Σ explicitly, for instance to increase the level of \"artificial noise\":","category":"page"},{"location":"overview/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"using LinearAlgebra\nobs = LinearGsnObs(v; Σ=(1e-5)I, full_obs=true)","category":"page"},{"location":"overview/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"Specifying full_obs=true is important, as it lets the compiler differentiate between an actual, full observation with some artificial noise and a (possibly) partial observation with very low level (or also artificial level) of noise. As a result, the compiler knows when the Markov property can be applied!","category":"page"},{"location":"overview/observation_schemes/#Linear-transformations-of-the-process-disturbed-by-Gaussian-noise-1","page":"Observation schemes","title":"Linear transformations of the process disturbed by Gaussian noise","text":"","category":"section"},{"location":"overview/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"A standard understanding of the expression in \\eqref{eq:obs_scheme}. An example could be:","category":"page"},{"location":"overview/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"using StaticArrays\nv = @SVector [1.0, 2.0, 3.0]\ntt = 2.0\nL = @SMatrix [1.0 0.0 2.0 0.0; 3.0 4.0 0.0 0.0; 0.0 1.0 0.0 1.0]\nΣ = SDiagonal(1.0, 1.0, 1e-11)\nobs = LinearGsnObs(tt, v; L = L, Σ = Σ)","category":"page"},{"location":"overview/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"for defining a three-dimensional observation v made at time 20 of a four-dimensional process X, where the first coordinate of the observation is X_t^1+2X_t^3+xi^1, with xi^1sim N(01), the second coordinate is 3X_t^1+4X_t^2+xi^2, with xi^2sim N(01), and the third coordinate is X_t^2+X_t^4, with no real noise (only an artificial one, needed for numerical reasons). We can display the summary of the observation with:","category":"page"},{"location":"overview/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"show(obs)","category":"page"},{"location":"overview/observation_schemes/#First-passage-time-observations-1","page":"Observation schemes","title":"First-passage time observations","text":"","category":"section"},{"location":"overview/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"Support for certain first-passage time settings is provided. Currently, the coordinate that is observed in a first-passage time setting must be devoid of any Wiener noise. By default LinearGsnObs sets the first-passage time info to NoFirstPassageTimes. However, this can be changed. For instance, to indicate in the example above that the last coordinate of v actually reaches level 30 for the very first time at time 20 we can specify the following:","category":"page"},{"location":"overview/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"fpt = FirstPassageTimeInfo(\n    (3,),\n    (3.0,),\n    (true,),\n    (false,),\n    (),\n)\nobs = LinearGsnObs(tt, v; L = L, Σ = Σ, fpt = fpt)","category":"page"},{"location":"overview/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"The last two entries in fpt specify additional reset times. For instance, instead of (false,) and () we could set (true,), (-1.0) to indicate that the process X_t^2+X_t^4 can do whatever before it falls below level -10 (in particular it can go above level 30), and that once it falls below -10, then from then on the first time it reaches level 30 happens at time 20. Note that","category":"page"},{"location":"overview/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"show(obs)","category":"page"},{"location":"overview/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"changes appropriately to display the new summary of the first-passage time info.","category":"page"},{"location":"overview/observation_schemes/#Beyond-linearity-and-Gaussianity-1","page":"Observation schemes","title":"Beyond linearity and Gaussianity","text":"","category":"section"},{"location":"overview/observation_schemes/#","page":"Observation schemes","title":"Observation schemes","text":"[TODO currently not implemented]","category":"page"},{"location":"#ObservationSchemes.jl-1","page":"Home","title":"ObservationSchemes.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This is a utility package belonging to a suite of packages BridgeSDEInference.jl. Its purpose is to provide systematic treatment of observation schemes for diffusion processes. The following types of observations are aimed at being implemented in this package:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"[x] Full observations of the underlying process\n[x] Linear translations of the underlying process, disturbed by Gaussian noise\n[x] First-passage time observations\n[x] First-passage time observations with additional resetting\n[x] Multiple observations of a single process\n[x] Multiple observations of multiple processes, coming possibly from different laws that share subsets of parameters (mixed-effect models)\n[ ] Non-linear observations\n[ ] Non-Gaussian observations","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Additionally, we provide infrastructure for defining priors over starting points Follow an Overview section to find out about various functionalities implemented in this package.","category":"page"},{"location":"overview/start_pt_prior/#Priors-over-starting-points-1","page":"Priors over starting points","title":"Priors over starting points","text":"","category":"section"},{"location":"overview/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"The starting points are always treated differently to observations due to the fact that there might be no observation made at the initial time. For this reason the package implements priors over starting points. All priors over starting points inherit from StartingPtPrior{T}. They all must implement methods rand, start_pt, inv_start_pt and logpdf.","category":"page"},{"location":"overview/start_pt_prior/#Known-starting-point-1","page":"Priors over starting points","title":"Known starting point","text":"","category":"section"},{"location":"overview/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"This is the simplest setting in which the starting point is assumed to be known. It can be defined with","category":"page"},{"location":"overview/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"x0 = [1.0, 2.0]\nx0_prior = KnownStartingPt(x0)","category":"page"},{"location":"overview/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"a call to rand or start_pt will simply return the fixed starting point and logpdf(x0_prior, y) evaluates to 0 so long as x0 == y.","category":"page"},{"location":"overview/start_pt_prior/#Gaussian-priors-1","page":"Priors over starting points","title":"Gaussian priors","text":"","category":"section"},{"location":"overview/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"A Gaussian prior over the starting point. Can be defined with","category":"page"},{"location":"overview/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"μ, Σ = [1.0, 2.0], [1.0 0.0; 0.0 1.0]\nx0_prior = GsnStartingPt(μ, Σ)","category":"page"},{"location":"overview/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"to set the mean and covariance to μ and Σ respectively. The underlying idea behind Gaussian starting point priors is that of non-centred parametrisation, so that a possibility of local updates is granted. More precisely any sampling is done with z∼N(0,1) variables, which are then transformed to N(μ,Σ) via linear transformations. In particular, sampling with rand can be done with local perturbations via Crank-Nicolson scheme. inv_start_pt returns the non-centrally parametrised noise z that produces given starting point x0 and start_pt is the reverse operation.","category":"page"},{"location":"overview/start_pt_prior/#Other-1","page":"Priors over starting points","title":"Other","text":"","category":"section"},{"location":"overview/start_pt_prior/#","page":"Priors over starting points","title":"Priors over starting points","text":"[TODO not implemented]","category":"page"}]
}
