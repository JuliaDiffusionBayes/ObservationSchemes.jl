<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model · ObservationSchemes.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ObservationSchemes.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">ObservationSchemes.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../get_started/overview/">Get started</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">User manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/single_observation/">A single observation</a></li><li><a class="tocitem" href="../../manual/start_pt_prior/">Priors over starting points</a></li><li><a class="tocitem" href="../../manual/multiple_observations/">Multiple observations</a></li><li><a class="tocitem" href="../../manual/observation_schemes/">Observation schemes</a></li><li><a class="tocitem" href="../../manual/utility_functions/">Utility fuctions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">How to...</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../how_to_guides/simple_os/">... ergonomically deal with simple observation schemes?</a></li><li><a class="tocitem" href="../../how_to_guides/custom_priors/">... define custom priors over starting points?</a></li><li><a class="tocitem" href="../../how_to_guides/custom_os/">... define custom observation schemes?</a></li><li><a class="tocitem" href="../../how_to_guides/dataframes/">... work with dataframes?</a></li><li><a class="tocitem" href="../../how_to_guides/csv_files/">... read data directly from a <code>.csv</code> file?</a></li><li><a class="tocitem" href="../../how_to_guides/save_to_files/">... save decorated data to a file?</a></li><li><a class="tocitem" href="../../how_to_guides/other_processes/">... deal with stochastic processes other than diffusions?</a></li><li><a class="tocitem" href="../../how_to_guides/update_params/">... leverage <code>AllObservations</code> to efficiently update parameters?</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model</a><ul class="internal"><li><a class="tocitem" href="#Generating-complete-data-1"><span>Generating complete data</span></a></li><li><a class="tocitem" href="#Observations-of-a-single-coordinate-1"><span>Observations of a single coordinate</span></a></li><li><a class="tocitem" href="#Full-code-from-the-tutorial-1"><span>Full code from the tutorial</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../module_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Defining an observation scheme for a single trajectory of a FitzHugh–Nagumo model</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDiffusionBayes/ObservationSchemes.jl/blob/master/docs/src/tutorials/single_path.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="tutorial_single_path-1"><a class="docs-heading-anchor" href="#tutorial_single_path-1">Defining an observation scheme for a single trajectory from the FitzHugh–Nagumo model</a><a class="docs-heading-anchor-permalink" href="#tutorial_single_path-1" title="Permalink"></a></h1><hr/><blockquote><p>In this tutorial we simulate data from the FitzHugh–Nagumo model and then show how to decorate it with information provided by <a href="https://github.com/JuliaDiffusionBayes/ObservationSchemes.jl">ObservationSchemes.jl</a>.</p></blockquote><h2 id="Generating-complete-data-1"><a class="docs-heading-anchor" href="#Generating-complete-data-1">Generating complete data</a><a class="docs-heading-anchor-permalink" href="#Generating-complete-data-1" title="Permalink"></a></h2><hr/><p>For this tutorial we will generate some data from the hypoelliptic, stochastic FitzHugh–Nagumo model that you can <a href="https://juliadiffusionbayes.github.io/DiffusionDefinition.jl/dev/predefined_processes/fitzhugh_nagumo/">read more about here</a>. To this end, we will use the functionality from the package <a href="https://juliadiffusionbayes.github.io/DiffusionDefinition.jl/dev/">DiffusionDefinition.jl</a>.</p><pre><code class="language-julia">using DiffusionDefinition, StaticArrays
@load_diffusion FitzHughNagumo

P = FitzHughNagumo(0.1, -0.8, 1.5, 0.0, 0.3)
tt = 0.0:0.0001:10.0
x0 = @SVector [-0.9, -0.9]
X = rand(P, tt, x0)</code></pre><p><code>X</code> above contains very high frequency observations (conceptually: a continuous recording) of both coordinates of the process without any extrinsic noise. However, when collecting real data one rarely has the luxury of being able to record all coordinates of the process, exactly and without any extrinsic noise. Instead, a very common setup is to record a subset of coordinates perturbed by some noise that is often assumed to be Gaussian. In mathematical notation this becomes:</p><div>\[V_t=LX_t+ξ,\quad ξ∼N(μ,Σ),\quad\mbox{for }t\in\{t_1,t_2,\dots\},\]</div><p>where <span>$L$</span>, <span>$Σ$</span> and <span>$μ$</span> are matrices and a vector of appropriate dimension. To define this types of observation with <a href="https://juliadiffusionbayes.github.io/ObservationSchemes.jl/dev/">ObservationSchemes.jl</a> we can use struct <code>LinearGsnObs</code>. Each observation must be decorated separately and becomes its own instance of <code>LinearGsnObs</code>. Consequently, for each observation we must indicate the time of its collection as well as its value and pass the two to a constructor of <code>LinearGsnObs</code>. We can optionally (and often will have to) specify the matrix <code>L</code> (which by default is assumed to be an identity matrix <code>I</code>), matrix <code>Σ</code> (which by default is assumed to be <code>1e-11*I</code>) and a vector <code>μ</code> (which by default is assumed to be a zero vector). In principle, we could even change <code>L</code>, <code>μ</code> and <code>Σ</code> from observation to observation, having as many observation schemes as there are observations, but we will (hopefully) rarely have to do that.</p><h2 id="Observations-of-a-single-coordinate-1"><a class="docs-heading-anchor" href="#Observations-of-a-single-coordinate-1">Observations of a single coordinate</a><a class="docs-heading-anchor-permalink" href="#Observations-of-a-single-coordinate-1" title="Permalink"></a></h2><hr/><p>FitzHugh–Nagumo model is used primarily to model the time evolution of the membrane potential. As in practice only the membrane potential itself is recorded (and corresponds to the values taken by the first coordinate) we will use:</p><div>\[L:=\left[\begin{matrix}1&amp; 0\end{matrix}\right].\]</div><p>We will also assume noisy measurements with Gaussian noise <span>$N(0,0.1^2)$</span> made every <span>$0.1$</span> seconds. Consequently, each observation has the following format:</p><pre><code class="language-julia">using ObservationSchemes
obs_template = LinearGsnObs(
    0.0, # dummy time variable
    (@SVector [0.0]); # dummy observation of a first coordinate
    L = (@SMatrix [1.0 0.0;]),
    Σ = (@SMatrix [0.01]),
)</code></pre><p>We could decorate every single observation separately, however, as all of them have the same format we can use a struct <code>ObsScheme</code> to define a template that can be applied to decorating the data efficiently. As there is only one observation type the <code>obs_template</code> is the only object we need to pass to <code>ObsScheme</code>:</p><pre><code class="language-julia">obs_scheme = ObsScheme(obs_template)</code></pre><p>If there were more than a single type of observation, then we could pass all of them to <code>ObsScheme</code> and then declare the pattern according to which different observations are to be selected. For more information see <a href="../../manual/observation_schemes/#obs_scheme-1">this page</a>.</p><p>As we don&#39;t yet have the raw data, only the entire, simulated process we should first reduce it down to raw data (which would be a list of time-points and a list of corresponding observations of the first coordinate) and then we could call <code>load_data</code> to apply <code>obs_scheme</code> to the raw data. However, we can also do all of that in a single step by calling <code>collect</code> to collect the data according to the <code>obs_scheme</code> directly from the simulated data:</p><pre><code class="language-julia">data = collect(obs_scheme, X, 1000, true)</code></pre><p>The <code>1000</code> indicates that only <code>1</code> in a <code>1000</code> points from <code>X</code> are supposed to be recorded. This corresponds exactly to <code>1</code> point every <code>0.1</code> seconds. <code>true</code> is a flag for omitting the initial point. We can now plot the simulated trajectory together with our data:</p><pre><code class="language-julia">const OBS = ObservationSchemes
using Plots
plot(X, Val(:vs_time), size=(800, 300))
scatter!(map(x-&gt;x.t, data), map(x-&gt;OBS.ν(x)[1], data), label=&quot;data&quot;)</code></pre><p><img src="../../assets/tutorials/single_path/fhn_single_coord.png" alt="fhn_single_coord"/></p><h2 id="Full-code-from-the-tutorial-1"><a class="docs-heading-anchor" href="#Full-code-from-the-tutorial-1">Full code from the tutorial</a><a class="docs-heading-anchor-permalink" href="#Full-code-from-the-tutorial-1" title="Permalink"></a></h2><hr/><pre><code class="language-julia">using DiffusionDefinition, StaticArrays
using ObservationSchemes, Plots, Random # Random used only for seeding
const OBS = ObservationSchemes

# use this seed for reproducing the tutorial exactly
Random.seed!(8)

@load_diffusion FitzHughNagumo
P = FitzHughNagumo(0.1, -0.8, 1.5, 0.0, 0.3)
tt = 0.0:0.0001:10.0
x0 = @SVector [-0.9, -0.9]
X = rand(P, tt, x0)

obs_template = LinearGsnObs(
    0.0, # dummy time variable
    (@SVector [0.0]); # dummy observation of a first coordinate
    L = (@SMatrix [1.0 0.0;]),
    Σ = (@SMatrix [0.01]),
)
obs_scheme = ObsScheme(obs_template)
data = collect(obs_scheme, X, 1000, true)

plot(X, Val(:vs_time), size=(800, 300))
scatter!(map(x-&gt;x.t, data), map(x-&gt;OBS.ν(x)[1], data), label=&quot;data&quot;)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../how_to_guides/update_params/">« ... leverage <code>AllObservations</code> to efficiently update parameters?</a><a class="docs-footer-nextpage" href="../../module_index/">Index »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 13 June 2020 08:40">Saturday 13 June 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
